// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.
/* eslint-disable @typescript-eslint/no-namespace */
export var Status;
(function (Status) {
    /** OK means the request completed successfully. */
    Status[Status["OK"] = 200] = "OK";
    /** Delivered means the transaction has been delivered. */
    Status[Status["Delivered"] = 201] = "Delivered";
    /** Pending means the transaction is pending. */
    Status[Status["Pending"] = 202] = "Pending";
    /** Remote means the transaction is a local reference to a remote. */
    Status[Status["Remote"] = 203] = "Remote";
    /** WrongPartition means the requested resource is assigned to a different network partition. */
    Status[Status["WrongPartition"] = 301] = "WrongPartition";
    /** BadRequest means the request was invalid. */
    Status[Status["BadRequest"] = 400] = "BadRequest";
    /** Unauthenticated means the signature could not be validated. */
    Status[Status["Unauthenticated"] = 401] = "Unauthenticated";
    /** InsufficientCredits means the signer does not have sufficient credits to execute the transaction. */
    Status[Status["InsufficientCredits"] = 402] = "InsufficientCredits";
    /** Unauthorized means the signer is not authorized to sign the transaction. */
    Status[Status["Unauthorized"] = 403] = "Unauthorized";
    /** NotFound means a record could not be found. */
    Status[Status["NotFound"] = 404] = "NotFound";
    /** NotAllowed means the requested action could not be performed. */
    Status[Status["NotAllowed"] = 405] = "NotAllowed";
    /** Rejected is returned when a transaction is rejected. */
    Status[Status["Rejected"] = 406] = "Rejected";
    /** Expired is returned when a transaction has expired. */
    Status[Status["Expired"] = 407] = "Expired";
    /** Conflict means the request failed due to a conflict. */
    Status[Status["Conflict"] = 409] = "Conflict";
    /** BadSignerVersion means the signer version does not match. */
    Status[Status["BadSignerVersion"] = 411] = "BadSignerVersion";
    /** BadTimestamp means the timestamp is invalid. */
    Status[Status["BadTimestamp"] = 412] = "BadTimestamp";
    /** BadUrlLength means the url length is too big. */
    Status[Status["BadUrlLength"] = 413] = "BadUrlLength";
    /** IncompleteChain means the chain does not include the full history. */
    Status[Status["IncompleteChain"] = 414] = "IncompleteChain";
    /** InsufficientBalance means the account balance is insufficient to satisfy the request. */
    Status[Status["InsufficientBalance"] = 415] = "InsufficientBalance";
    /** InternalError means an internal error occurred. */
    Status[Status["InternalError"] = 500] = "InternalError";
    /** UnknownError means an unknown error occurred. */
    Status[Status["UnknownError"] = 501] = "UnknownError";
    /** EncodingError means encoding or decoding failed. */
    Status[Status["EncodingError"] = 502] = "EncodingError";
    /** FatalError means something has gone seriously wrong. */
    Status[Status["FatalError"] = 503] = "FatalError";
    /** NotReady means the receiver is not ready to satisfy the request. */
    Status[Status["NotReady"] = 504] = "NotReady";
    /** WrongType means the record is not the expected type. */
    Status[Status["WrongType"] = 505] = "WrongType";
    /** NoPeer means the receiver cannot find a peer to satisfy the request. */
    Status[Status["NoPeer"] = 506] = "NoPeer";
    /** PeerMisbehaved means a peer behaved incorrectly. */
    Status[Status["PeerMisbehaved"] = 507] = "PeerMisbehaved";
    /** InvalidRecord means the database has one or more invalid records. */
    Status[Status["InvalidRecord"] = 508] = "InvalidRecord";
    /** StreamAborted is equivalent to [io.ErrUnexpectedEOF]. */
    Status[Status["StreamAborted"] = 509] = "StreamAborted";
})(Status || (Status = {}));
/** @ignore */
(function (Status) {
    function fromObject(obj) {
        if (typeof obj === "number")
            return obj;
        return byName(obj);
    }
    Status.fromObject = fromObject;
    function byName(name) {
        switch (name.toLowerCase()) {
            case "ok":
                return Status.OK;
            case "delivered":
                return Status.Delivered;
            case "pending":
                return Status.Pending;
            case "remote":
                return Status.Remote;
            case "wrongpartition":
                return Status.WrongPartition;
            case "badrequest":
                return Status.BadRequest;
            case "unauthenticated":
                return Status.Unauthenticated;
            case "insufficientcredits":
                return Status.InsufficientCredits;
            case "unauthorized":
                return Status.Unauthorized;
            case "notfound":
                return Status.NotFound;
            case "notallowed":
                return Status.NotAllowed;
            case "rejected":
                return Status.Rejected;
            case "expired":
                return Status.Expired;
            case "conflict":
                return Status.Conflict;
            case "badsignerversion":
                return Status.BadSignerVersion;
            case "badtimestamp":
                return Status.BadTimestamp;
            case "badurllength":
                return Status.BadUrlLength;
            case "incompletechain":
                return Status.IncompleteChain;
            case "insufficientbalance":
                return Status.InsufficientBalance;
            case "internalerror":
                return Status.InternalError;
            case "unknownerror":
                return Status.UnknownError;
            case "encodingerror":
                return Status.EncodingError;
            case "fatalerror":
                return Status.FatalError;
            case "notready":
                return Status.NotReady;
            case "wrongtype":
                return Status.WrongType;
            case "nopeer":
                return Status.NoPeer;
            case "peermisbehaved":
                return Status.PeerMisbehaved;
            case "invalidrecord":
                return Status.InvalidRecord;
            case "streamaborted":
                return Status.StreamAborted;
            default:
                throw new Error(`Unknown Status '${name}'`);
        }
    }
    Status.byName = byName;
    function getName(v) {
        switch (v) {
            case Status.OK:
                return "ok";
            case Status.Delivered:
                return "delivered";
            case Status.Pending:
                return "pending";
            case Status.Remote:
                return "remote";
            case Status.WrongPartition:
                return "wrongPartition";
            case Status.BadRequest:
                return "badRequest";
            case Status.Unauthenticated:
                return "unauthenticated";
            case Status.InsufficientCredits:
                return "insufficientCredits";
            case Status.Unauthorized:
                return "unauthorized";
            case Status.NotFound:
                return "notFound";
            case Status.NotAllowed:
                return "notAllowed";
            case Status.Rejected:
                return "rejected";
            case Status.Expired:
                return "expired";
            case Status.Conflict:
                return "conflict";
            case Status.BadSignerVersion:
                return "badSignerVersion";
            case Status.BadTimestamp:
                return "badTimestamp";
            case Status.BadUrlLength:
                return "badUrlLength";
            case Status.IncompleteChain:
                return "incompleteChain";
            case Status.InsufficientBalance:
                return "insufficientBalance";
            case Status.InternalError:
                return "internalError";
            case Status.UnknownError:
                return "unknownError";
            case Status.EncodingError:
                return "encodingError";
            case Status.FatalError:
                return "fatalError";
            case Status.NotReady:
                return "notReady";
            case Status.WrongType:
                return "wrongType";
            case Status.NoPeer:
                return "noPeer";
            case Status.PeerMisbehaved:
                return "peerMisbehaved";
            case Status.InvalidRecord:
                return "invalidRecord";
            case Status.StreamAborted:
                return "streamAborted";
            default:
                throw new Error(`Unknown Status ${v}`);
        }
    }
    Status.getName = getName;
})(Status || (Status = {}));
//# sourceMappingURL=enums_gen.js.map