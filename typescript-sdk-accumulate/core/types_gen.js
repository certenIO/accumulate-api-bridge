var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { AccountAuthOperationType, AccountType, BookType, DataEntryType, ExecutorVersion, KeyPageOperationType, NetworkMaintenanceOperationType, PartitionType, SignatureType, TransactionType, VoteType, } from "./enums_gen.js";
import { Account, AccountAuthOperation, DataEntry, KeyPageOperation, NetworkMaintenanceOperation, Signature, TransactionBody, } from "./unions_gen.js";
import { AccumulateTxID as TxID } from "../address/txid.js";
import { AccumulateURL as URL } from "../address/url.js";
import { Buffer } from "../common/buffer.js";
import { encodeAs } from "../encoding/index.js";
import * as errors2 from "../errors/index.js";
import * as merkle from "../merkle/index.js";
import { ChainType } from "../merkle/index.js";
import { TransactionBase } from "./base.js";
// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */
// Lazy loaders to avoid circular dependency - use delayed imports to avoid Jest issues
let _Fee;
let _AllowedTransactions;
let _AnchorBody;
let _TransactionResult;
let _Signer;
function getFeeClass() {
    if (!_Fee) {
        // Use dynamic import for Jest compatibility
        _Fee = {
            fromObject: (obj) => {
                if (typeof obj === "string")
                    return Number(obj);
                return obj;
            }
        };
    }
    return _Fee;
}
function getAllowedTransactionsClass() {
    if (!_AllowedTransactions) {
        _AllowedTransactions = {
            fromObject: (obj) => {
                if (!obj.length)
                    return [];
                if (typeof obj[0] === "number")
                    return obj;
                return obj.map((v) => typeof v === "string" ? 0 : v); // Simplified
            }
        };
    }
    return _AllowedTransactions;
}
function getAnchorBodyClass() {
    if (!_AnchorBody) {
        _AnchorBody = {
            fromObject: (obj) => obj
        };
    }
    return _AnchorBody;
}
function getTransactionResultClass() {
    if (!_TransactionResult) {
        _TransactionResult = {
            fromObject: (obj) => obj
        };
    }
    return _TransactionResult;
}
function getSignerClass() {
    if (!_Signer) {
        _Signer = {
            fromObject: (obj) => obj
        };
    }
    return _Signer;
}
export class ADI {
    constructor(args) {
        this.type = AccountType.Identity;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => v == undefined ? undefined : v instanceof AuthorityEntry ? v : new AuthorityEntry(v));
    }
    copy() {
        return new ADI(this.asObject());
    }
    asObject() {
        return {
            type: "identity",
            url: this.url === undefined ? undefined : this.url.toString(),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], ADI.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], ADI.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3, 1).repeatable.reference)
], ADI.prototype, "authorities", void 0);
export class AccountAuth {
    constructor(args) {
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => v == undefined ? undefined : v instanceof AuthorityEntry ? v : new AuthorityEntry(v));
    }
    copy() {
        return new AccountAuth(this.asObject());
    }
    asObject() {
        return {
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).repeatable.reference)
], AccountAuth.prototype, "authorities", void 0);
export class AccumulateDataEntry {
    constructor(args) {
        this.type = DataEntryType.Accumulate;
        this.data =
            args.data == undefined
                ? undefined
                : args.data.map((v) => v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"));
    }
    copy() {
        return new AccumulateDataEntry(this.asObject());
    }
    asObject() {
        return {
            type: "accumulate",
            data: this.data === undefined
                ? undefined
                : this.data?.map((v) => v == undefined ? undefined : v && Buffer.from(v).toString("hex")),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(DataEntryType))
], AccumulateDataEntry.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).repeatable.bytes)
], AccumulateDataEntry.prototype, "data", void 0);
export class AcmeFaucet {
    constructor(args) {
        this.type = TransactionType.AcmeFaucet;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
    }
    copy() {
        return new AcmeFaucet(this.asObject());
    }
    asObject() {
        return {
            type: "acmeFaucet",
            url: this.url === undefined ? undefined : this.url.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], AcmeFaucet.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], AcmeFaucet.prototype, "url", void 0);
export class AcmeOracle {
    constructor(args) {
        this.price = args.price == undefined ? undefined : args.price;
    }
    copy() {
        return new AcmeOracle(this.asObject());
    }
    asObject() {
        return {
            price: this.price === undefined ? undefined : this.price,
        };
    }
}
__decorate([
    (encodeAs.field(1).uint)
], AcmeOracle.prototype, "price", void 0);
export class ActivateProtocolVersion {
    constructor(args) {
        this.type = TransactionType.ActivateProtocolVersion;
        this.version = args.version == undefined ? undefined : ExecutorVersion.fromObject(args.version);
    }
    copy() {
        return new ActivateProtocolVersion(this.asObject());
    }
    asObject() {
        return {
            type: "activateProtocolVersion",
            version: this.version === undefined ? undefined : ExecutorVersion.getName(this.version),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], ActivateProtocolVersion.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).enum)
], ActivateProtocolVersion.prototype, "version", void 0);
export class AddAccountAuthorityOperation {
    constructor(args) {
        this.type = AccountAuthOperationType.AddAuthority;
        this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    }
    copy() {
        return new AddAccountAuthorityOperation(this.asObject());
    }
    asObject() {
        return {
            type: "addAuthority",
            authority: this.authority === undefined ? undefined : this.authority.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountAuthOperationType))
], AddAccountAuthorityOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], AddAccountAuthorityOperation.prototype, "authority", void 0);
export class AddCredits {
    constructor(args) {
        this.type = TransactionType.AddCredits;
        this.recipient = args.recipient == undefined ? undefined : URL.parse(args.recipient);
        this.amount =
            args.amount == undefined
                ? undefined
                : typeof args.amount === "bigint"
                    ? args.amount
                    : BigInt(args.amount);
        this.oracle = args.oracle == undefined ? undefined : args.oracle;
    }
    copy() {
        return new AddCredits(this.asObject());
    }
    asObject() {
        return {
            type: "addCredits",
            recipient: this.recipient === undefined ? undefined : this.recipient.toString(),
            amount: this.amount === undefined ? undefined : this.amount.toString(),
            oracle: this.oracle === undefined ? undefined : this.oracle,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], AddCredits.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], AddCredits.prototype, "recipient", void 0);
__decorate([
    (encodeAs.field(3).bigInt)
], AddCredits.prototype, "amount", void 0);
__decorate([
    (encodeAs.field(4).uint)
], AddCredits.prototype, "oracle", void 0);
export class AddCreditsResult {
    constructor(args) {
        this.type = TransactionType.AddCredits;
        this.amount =
            args.amount == undefined
                ? undefined
                : typeof args.amount === "bigint"
                    ? args.amount
                    : BigInt(args.amount);
        this.credits = args.credits == undefined ? undefined : args.credits;
        this.oracle = args.oracle == undefined ? undefined : args.oracle;
    }
    copy() {
        return new AddCreditsResult(this.asObject());
    }
    asObject() {
        return {
            type: "addCredits",
            amount: this.amount === undefined ? undefined : this.amount.toString(),
            credits: this.credits === undefined ? undefined : this.credits,
            oracle: this.oracle === undefined ? undefined : this.oracle,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], AddCreditsResult.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bigInt)
], AddCreditsResult.prototype, "amount", void 0);
__decorate([
    (encodeAs.field(3).uint)
], AddCreditsResult.prototype, "credits", void 0);
__decorate([
    (encodeAs.field(4).uint)
], AddCreditsResult.prototype, "oracle", void 0);
export class AddKeyOperation {
    constructor(args) {
        this.type = KeyPageOperationType.Add;
        this.entry =
            args.entry == undefined
                ? undefined
                : args.entry instanceof KeySpecParams
                    ? args.entry
                    : new KeySpecParams(args.entry);
    }
    copy() {
        return new AddKeyOperation(this.asObject());
    }
    asObject() {
        return {
            type: "add",
            entry: this.entry === undefined ? undefined : this.entry.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(KeyPageOperationType))
], AddKeyOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).reference)
], AddKeyOperation.prototype, "entry", void 0);
export class AnchorLedger {
    constructor(args) {
        this.type = AccountType.AnchorLedger;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.minorBlockSequenceNumber =
            args.minorBlockSequenceNumber == undefined ? undefined : args.minorBlockSequenceNumber;
        this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
        this.majorBlockTime =
            args.majorBlockTime == undefined
                ? undefined
                : args.majorBlockTime instanceof Date
                    ? args.majorBlockTime
                    : new Date(args.majorBlockTime);
        this.pendingMajorBlockAnchors =
            args.pendingMajorBlockAnchors == undefined
                ? undefined
                : args.pendingMajorBlockAnchors.map((v) => (v == undefined ? undefined : URL.parse(v)));
        this.sequence =
            args.sequence == undefined
                ? undefined
                : args.sequence.map((v) => v == undefined
                    ? undefined
                    : v instanceof PartitionSyntheticLedger
                        ? v
                        : new PartitionSyntheticLedger(v));
    }
    copy() {
        return new AnchorLedger(this.asObject());
    }
    asObject() {
        return {
            type: "anchorLedger",
            url: this.url === undefined ? undefined : this.url.toString(),
            minorBlockSequenceNumber: this.minorBlockSequenceNumber === undefined ? undefined : this.minorBlockSequenceNumber,
            majorBlockIndex: this.majorBlockIndex === undefined ? undefined : this.majorBlockIndex,
            majorBlockTime: this.majorBlockTime === undefined ? undefined : this.majorBlockTime,
            pendingMajorBlockAnchors: this.pendingMajorBlockAnchors === undefined
                ? undefined
                : this.pendingMajorBlockAnchors?.map((v) => (v == undefined ? undefined : v.toString())),
            sequence: this.sequence === undefined
                ? undefined
                : this.sequence?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], AnchorLedger.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], AnchorLedger.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).uint)
], AnchorLedger.prototype, "minorBlockSequenceNumber", void 0);
__decorate([
    (encodeAs.field(4).uint)
], AnchorLedger.prototype, "majorBlockIndex", void 0);
__decorate([
    (encodeAs.field(5).time)
], AnchorLedger.prototype, "majorBlockTime", void 0);
__decorate([
    (encodeAs.field(6).repeatable.url)
], AnchorLedger.prototype, "pendingMajorBlockAnchors", void 0);
__decorate([
    (encodeAs.field(7).repeatable.reference)
], AnchorLedger.prototype, "sequence", void 0);
export class AnchorMetadata {
    constructor(args) {
        this.name = args.name == undefined ? undefined : args.name;
        this.type = args.type == undefined ? undefined : ChainType.fromObject(args.type);
        this.account = args.account == undefined ? undefined : URL.parse(args.account);
        this.index = args.index == undefined ? undefined : args.index;
        this.sourceIndex = args.sourceIndex == undefined ? undefined : args.sourceIndex;
        this.sourceBlock = args.sourceBlock == undefined ? undefined : args.sourceBlock;
        this.entry =
            args.entry == undefined
                ? undefined
                : args.entry instanceof Uint8Array
                    ? args.entry
                    : Buffer.from(args.entry, "hex");
    }
    copy() {
        return new AnchorMetadata(this.asObject());
    }
    asObject() {
        return {
            name: this.name === undefined ? undefined : this.name,
            type: this.type === undefined ? undefined : ChainType.getName(this.type),
            account: this.account === undefined ? undefined : this.account.toString(),
            index: this.index === undefined ? undefined : this.index,
            sourceIndex: this.sourceIndex === undefined ? undefined : this.sourceIndex,
            sourceBlock: this.sourceBlock === undefined ? undefined : this.sourceBlock,
            entry: this.entry === undefined
                ? undefined
                : this.entry && Buffer.from(this.entry).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1, 1).string)
], AnchorMetadata.prototype, "name", void 0);
__decorate([
    (encodeAs.field(1, 2).enum)
], AnchorMetadata.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], AnchorMetadata.prototype, "account", void 0);
__decorate([
    (encodeAs.field(3).uint)
], AnchorMetadata.prototype, "index", void 0);
__decorate([
    (encodeAs.field(4).uint)
], AnchorMetadata.prototype, "sourceIndex", void 0);
__decorate([
    (encodeAs.field(5).uint)
], AnchorMetadata.prototype, "sourceBlock", void 0);
__decorate([
    (encodeAs.field(6).bytes)
], AnchorMetadata.prototype, "entry", void 0);
export class AnnotatedReceipt {
    constructor(args) {
        this.receipt =
            args.receipt == undefined
                ? undefined
                : args.receipt instanceof merkle.Receipt
                    ? args.receipt
                    : new merkle.Receipt(args.receipt);
        this.anchor =
            args.anchor == undefined
                ? undefined
                : args.anchor instanceof AnchorMetadata
                    ? args.anchor
                    : new AnchorMetadata(args.anchor);
    }
    copy() {
        return new AnnotatedReceipt(this.asObject());
    }
    asObject() {
        return {
            receipt: this.receipt === undefined ? undefined : this.receipt.asObject(),
            anchor: this.anchor === undefined ? undefined : this.anchor.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).reference)
], AnnotatedReceipt.prototype, "receipt", void 0);
__decorate([
    (encodeAs.field(2).reference)
], AnnotatedReceipt.prototype, "anchor", void 0);
export class AuthorityEntry {
    constructor(args) {
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.disabled = args.disabled == undefined ? undefined : args.disabled;
    }
    copy() {
        return new AuthorityEntry(this.asObject());
    }
    asObject() {
        return {
            url: this.url === undefined ? undefined : this.url.toString(),
            disabled: this.disabled === undefined ? undefined : this.disabled,
        };
    }
}
__decorate([
    (encodeAs.field(1).url)
], AuthorityEntry.prototype, "url", void 0);
__decorate([
    (encodeAs.field(2).bool)
], AuthorityEntry.prototype, "disabled", void 0);
export class AuthoritySignature {
    constructor(args) {
        this.type = SignatureType.Authority;
        this.origin = args.origin == undefined ? undefined : URL.parse(args.origin);
        this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.txID = args.txID == undefined ? undefined : TxID.parse(args.txID);
        this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
        this.delegator =
            args.delegator == undefined
                ? undefined
                : args.delegator.map((v) => (v == undefined ? undefined : URL.parse(v)));
        this.memo = args.memo == undefined ? undefined : args.memo;
    }
    copy() {
        return new AuthoritySignature(this.asObject());
    }
    asObject() {
        return {
            type: "authority",
            origin: this.origin === undefined ? undefined : this.origin.toString(),
            authority: this.authority === undefined ? undefined : this.authority.toString(),
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            txID: this.txID === undefined ? undefined : this.txID.toString(),
            cause: this.cause === undefined ? undefined : this.cause.toString(),
            delegator: this.delegator === undefined
                ? undefined
                : this.delegator?.map((v) => (v == undefined ? undefined : v.toString())),
            memo: this.memo === undefined ? undefined : this.memo,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], AuthoritySignature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], AuthoritySignature.prototype, "origin", void 0);
__decorate([
    (encodeAs.field(3).url)
], AuthoritySignature.prototype, "authority", void 0);
__decorate([
    (encodeAs.field(4).enum)
], AuthoritySignature.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(5).txid)
], AuthoritySignature.prototype, "txID", void 0);
__decorate([
    (encodeAs.field(6).txid)
], AuthoritySignature.prototype, "cause", void 0);
__decorate([
    (encodeAs.field(7).repeatable.url)
], AuthoritySignature.prototype, "delegator", void 0);
__decorate([
    (encodeAs.field(8).string)
], AuthoritySignature.prototype, "memo", void 0);
export class BTCLegacySignature {
    constructor(args) {
        this.type = SignatureType.BTCLegacy;
        this.publicKey =
            args.publicKey == undefined
                ? undefined
                : args.publicKey instanceof Uint8Array
                    ? args.publicKey
                    : Buffer.from(args.publicKey, "hex");
        this.signature =
            args.signature == undefined
                ? undefined
                : args.signature instanceof Uint8Array
                    ? args.signature
                    : Buffer.from(args.signature, "hex");
        this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
        this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
        this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
        this.memo = args.memo == undefined ? undefined : args.memo;
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
    }
    copy() {
        return new BTCLegacySignature(this.asObject());
    }
    asObject() {
        return {
            type: "btclegacy",
            publicKey: this.publicKey === undefined
                ? undefined
                : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
            signature: this.signature === undefined
                ? undefined
                : this.signature && Buffer.from(this.signature).toString("hex"),
            signer: this.signer === undefined ? undefined : this.signer.toString(),
            signerVersion: this.signerVersion === undefined ? undefined : this.signerVersion,
            timestamp: this.timestamp === undefined ? undefined : this.timestamp,
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
            memo: this.memo === undefined ? undefined : this.memo,
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], BTCLegacySignature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bytes)
], BTCLegacySignature.prototype, "publicKey", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], BTCLegacySignature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(4).url)
], BTCLegacySignature.prototype, "signer", void 0);
__decorate([
    (encodeAs.field(5).uint)
], BTCLegacySignature.prototype, "signerVersion", void 0);
__decorate([
    (encodeAs.field(6).uint)
], BTCLegacySignature.prototype, "timestamp", void 0);
__decorate([
    (encodeAs.field(7).enum)
], BTCLegacySignature.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(8).hash)
], BTCLegacySignature.prototype, "transactionHash", void 0);
__decorate([
    (encodeAs.field(9).string)
], BTCLegacySignature.prototype, "memo", void 0);
__decorate([
    (encodeAs.field(10).bytes)
], BTCLegacySignature.prototype, "data", void 0);
export class BTCSignature {
    constructor(args) {
        this.type = SignatureType.BTC;
        this.publicKey =
            args.publicKey == undefined
                ? undefined
                : args.publicKey instanceof Uint8Array
                    ? args.publicKey
                    : Buffer.from(args.publicKey, "hex");
        this.signature =
            args.signature == undefined
                ? undefined
                : args.signature instanceof Uint8Array
                    ? args.signature
                    : Buffer.from(args.signature, "hex");
        this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
        this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
        this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
        this.memo = args.memo == undefined ? undefined : args.memo;
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
    }
    copy() {
        return new BTCSignature(this.asObject());
    }
    asObject() {
        return {
            type: "btc",
            publicKey: this.publicKey === undefined
                ? undefined
                : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
            signature: this.signature === undefined
                ? undefined
                : this.signature && Buffer.from(this.signature).toString("hex"),
            signer: this.signer === undefined ? undefined : this.signer.toString(),
            signerVersion: this.signerVersion === undefined ? undefined : this.signerVersion,
            timestamp: this.timestamp === undefined ? undefined : this.timestamp,
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
            memo: this.memo === undefined ? undefined : this.memo,
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], BTCSignature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bytes)
], BTCSignature.prototype, "publicKey", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], BTCSignature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(4).url)
], BTCSignature.prototype, "signer", void 0);
__decorate([
    (encodeAs.field(5).uint)
], BTCSignature.prototype, "signerVersion", void 0);
__decorate([
    (encodeAs.field(6).uint)
], BTCSignature.prototype, "timestamp", void 0);
__decorate([
    (encodeAs.field(7).enum)
], BTCSignature.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(8).hash)
], BTCSignature.prototype, "transactionHash", void 0);
__decorate([
    (encodeAs.field(9).string)
], BTCSignature.prototype, "memo", void 0);
__decorate([
    (encodeAs.field(10).bytes)
], BTCSignature.prototype, "data", void 0);
export class BlockEntry {
    constructor(args) {
        this.account = args.account == undefined ? undefined : URL.parse(args.account);
        this.chain = args.chain == undefined ? undefined : args.chain;
        this.index = args.index == undefined ? undefined : args.index;
    }
    copy() {
        return new BlockEntry(this.asObject());
    }
    asObject() {
        return {
            account: this.account === undefined ? undefined : this.account.toString(),
            chain: this.chain === undefined ? undefined : this.chain,
            index: this.index === undefined ? undefined : this.index,
        };
    }
}
__decorate([
    (encodeAs.field(1).url)
], BlockEntry.prototype, "account", void 0);
__decorate([
    (encodeAs.field(2).string)
], BlockEntry.prototype, "chain", void 0);
__decorate([
    (encodeAs.field(3).keepEmpty.uint)
], BlockEntry.prototype, "index", void 0);
export class BlockLedger {
    constructor(args) {
        this.type = AccountType.BlockLedger;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.index = args.index == undefined ? undefined : args.index;
        this.time =
            args.time == undefined
                ? undefined
                : args.time instanceof Date
                    ? args.time
                    : new Date(args.time);
        this.entries =
            args.entries == undefined
                ? undefined
                : args.entries.map((v) => v == undefined ? undefined : v instanceof BlockEntry ? v : new BlockEntry(v));
    }
    copy() {
        return new BlockLedger(this.asObject());
    }
    asObject() {
        return {
            type: "blockLedger",
            url: this.url === undefined ? undefined : this.url.toString(),
            index: this.index === undefined ? undefined : this.index,
            time: this.time === undefined ? undefined : this.time,
            entries: this.entries === undefined
                ? undefined
                : this.entries?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], BlockLedger.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], BlockLedger.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).uint)
], BlockLedger.prototype, "index", void 0);
__decorate([
    (encodeAs.field(4).time)
], BlockLedger.prototype, "time", void 0);
__decorate([
    (encodeAs.field(5).repeatable.reference)
], BlockLedger.prototype, "entries", void 0);
export class BlockValidatorAnchor {
    constructor(args) {
        this.type = TransactionType.BlockValidatorAnchor;
        this.source = args.source == undefined ? undefined : URL.parse(args.source);
        this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
        this.minorBlockIndex = args.minorBlockIndex == undefined ? undefined : args.minorBlockIndex;
        this.rootChainIndex = args.rootChainIndex == undefined ? undefined : args.rootChainIndex;
        this.rootChainAnchor =
            args.rootChainAnchor == undefined
                ? undefined
                : args.rootChainAnchor instanceof Uint8Array
                    ? args.rootChainAnchor
                    : Buffer.from(args.rootChainAnchor, "hex");
        this.stateTreeAnchor =
            args.stateTreeAnchor == undefined
                ? undefined
                : args.stateTreeAnchor instanceof Uint8Array
                    ? args.stateTreeAnchor
                    : Buffer.from(args.stateTreeAnchor, "hex");
        this.acmeBurnt =
            args.acmeBurnt == undefined
                ? undefined
                : typeof args.acmeBurnt === "bigint"
                    ? args.acmeBurnt
                    : BigInt(args.acmeBurnt);
    }
    copy() {
        return new BlockValidatorAnchor(this.asObject());
    }
    asObject() {
        return {
            type: "blockValidatorAnchor",
            source: this.source === undefined ? undefined : this.source.toString(),
            majorBlockIndex: this.majorBlockIndex === undefined ? undefined : this.majorBlockIndex,
            minorBlockIndex: this.minorBlockIndex === undefined ? undefined : this.minorBlockIndex,
            rootChainIndex: this.rootChainIndex === undefined ? undefined : this.rootChainIndex,
            rootChainAnchor: this.rootChainAnchor === undefined
                ? undefined
                : this.rootChainAnchor && Buffer.from(this.rootChainAnchor).toString("hex"),
            stateTreeAnchor: this.stateTreeAnchor === undefined
                ? undefined
                : this.stateTreeAnchor && Buffer.from(this.stateTreeAnchor).toString("hex"),
            acmeBurnt: this.acmeBurnt === undefined ? undefined : this.acmeBurnt.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], BlockValidatorAnchor.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2, 1).url)
], BlockValidatorAnchor.prototype, "source", void 0);
__decorate([
    (encodeAs.field(2, 2).uint)
], BlockValidatorAnchor.prototype, "majorBlockIndex", void 0);
__decorate([
    (encodeAs.field(2, 3).uint)
], BlockValidatorAnchor.prototype, "minorBlockIndex", void 0);
__decorate([
    (encodeAs.field(2, 4).uint)
], BlockValidatorAnchor.prototype, "rootChainIndex", void 0);
__decorate([
    (encodeAs.field(2, 5).hash)
], BlockValidatorAnchor.prototype, "rootChainAnchor", void 0);
__decorate([
    (encodeAs.field(2, 6).hash)
], BlockValidatorAnchor.prototype, "stateTreeAnchor", void 0);
__decorate([
    (encodeAs.field(3).bigInt)
], BlockValidatorAnchor.prototype, "acmeBurnt", void 0);
export class BurnCredits {
    constructor(args) {
        this.type = TransactionType.BurnCredits;
        this.amount = args.amount == undefined ? undefined : args.amount;
    }
    copy() {
        return new BurnCredits(this.asObject());
    }
    asObject() {
        return {
            type: "burnCredits",
            amount: this.amount === undefined ? undefined : this.amount,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], BurnCredits.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).uint)
], BurnCredits.prototype, "amount", void 0);
export class BurnTokens {
    constructor(args) {
        this.type = TransactionType.BurnTokens;
        this.amount =
            args.amount == undefined
                ? undefined
                : typeof args.amount === "bigint"
                    ? args.amount
                    : BigInt(args.amount);
    }
    copy() {
        return new BurnTokens(this.asObject());
    }
    asObject() {
        return {
            type: "burnTokens",
            amount: this.amount === undefined ? undefined : this.amount.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], BurnTokens.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bigInt)
], BurnTokens.prototype, "amount", void 0);
export class ChainMetadata {
    constructor(args) {
        this.name = args.name == undefined ? undefined : args.name;
        this.type = args.type == undefined ? undefined : ChainType.fromObject(args.type);
    }
    copy() {
        return new ChainMetadata(this.asObject());
    }
    asObject() {
        return {
            name: this.name === undefined ? undefined : this.name,
            type: this.type === undefined ? undefined : ChainType.getName(this.type),
        };
    }
}
__decorate([
    (encodeAs.field(1).string)
], ChainMetadata.prototype, "name", void 0);
__decorate([
    (encodeAs.field(2).enum)
], ChainMetadata.prototype, "type", void 0);
export class ChainParams {
    constructor(args) {
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
        this.isUpdate = args.isUpdate == undefined ? undefined : args.isUpdate;
    }
    copy() {
        return new ChainParams(this.asObject());
    }
    asObject() {
        return {
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
            isUpdate: this.isUpdate === undefined ? undefined : this.isUpdate,
        };
    }
}
__decorate([
    (encodeAs.field(1).bytes)
], ChainParams.prototype, "data", void 0);
__decorate([
    (encodeAs.field(2).bool)
], ChainParams.prototype, "isUpdate", void 0);
export class CreateDataAccount {
    constructor(args) {
        this.type = TransactionType.CreateDataAccount;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => (v == undefined ? undefined : URL.parse(v)));
    }
    copy() {
        return new CreateDataAccount(this.asObject());
    }
    asObject() {
        return {
            type: "createDataAccount",
            url: this.url === undefined ? undefined : this.url.toString(),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.toString())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], CreateDataAccount.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], CreateDataAccount.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).repeatable.url)
], CreateDataAccount.prototype, "authorities", void 0);
export class CreateIdentity {
    constructor(args) {
        this.type = TransactionType.CreateIdentity;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.keyHash =
            args.keyHash == undefined
                ? undefined
                : args.keyHash instanceof Uint8Array
                    ? args.keyHash
                    : Buffer.from(args.keyHash, "hex");
        this.keyBookUrl = args.keyBookUrl == undefined ? undefined : URL.parse(args.keyBookUrl);
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => (v == undefined ? undefined : URL.parse(v)));
    }
    copy() {
        return new CreateIdentity(this.asObject());
    }
    asObject() {
        return {
            type: "createIdentity",
            url: this.url === undefined ? undefined : this.url.toString(),
            keyHash: this.keyHash === undefined
                ? undefined
                : this.keyHash && Buffer.from(this.keyHash).toString("hex"),
            keyBookUrl: this.keyBookUrl === undefined ? undefined : this.keyBookUrl.toString(),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.toString())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], CreateIdentity.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], CreateIdentity.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], CreateIdentity.prototype, "keyHash", void 0);
__decorate([
    (encodeAs.field(4).url)
], CreateIdentity.prototype, "keyBookUrl", void 0);
__decorate([
    (encodeAs.field(6).repeatable.url)
], CreateIdentity.prototype, "authorities", void 0);
export class CreateKeyBook {
    constructor(args) {
        this.type = TransactionType.CreateKeyBook;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.publicKeyHash =
            args.publicKeyHash == undefined
                ? undefined
                : args.publicKeyHash instanceof Uint8Array
                    ? args.publicKeyHash
                    : Buffer.from(args.publicKeyHash, "hex");
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => (v == undefined ? undefined : URL.parse(v)));
    }
    copy() {
        return new CreateKeyBook(this.asObject());
    }
    asObject() {
        return {
            type: "createKeyBook",
            url: this.url === undefined ? undefined : this.url.toString(),
            publicKeyHash: this.publicKeyHash === undefined
                ? undefined
                : this.publicKeyHash && Buffer.from(this.publicKeyHash).toString("hex"),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.toString())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], CreateKeyBook.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], CreateKeyBook.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], CreateKeyBook.prototype, "publicKeyHash", void 0);
__decorate([
    (encodeAs.field(5).repeatable.url)
], CreateKeyBook.prototype, "authorities", void 0);
export class CreateKeyPage {
    constructor(args) {
        this.type = TransactionType.CreateKeyPage;
        this.keys =
            args.keys == undefined
                ? undefined
                : args.keys.map((v) => v == undefined ? undefined : v instanceof KeySpecParams ? v : new KeySpecParams(v));
    }
    copy() {
        return new CreateKeyPage(this.asObject());
    }
    asObject() {
        return {
            type: "createKeyPage",
            keys: this.keys === undefined
                ? undefined
                : this.keys?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], CreateKeyPage.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).repeatable.reference)
], CreateKeyPage.prototype, "keys", void 0);
export class CreateLiteTokenAccount {
    constructor(_) {
        this.type = TransactionType.CreateLiteTokenAccount;
    }
    copy() {
        return new CreateLiteTokenAccount(this.asObject());
    }
    asObject() {
        return {
            type: "createLiteTokenAccount",
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], CreateLiteTokenAccount.prototype, "type", void 0);
export class CreateToken {
    constructor(args) {
        this.type = TransactionType.CreateToken;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.symbol = args.symbol == undefined ? undefined : args.symbol;
        this.precision = args.precision == undefined ? undefined : args.precision;
        this.properties = args.properties == undefined ? undefined : URL.parse(args.properties);
        this.supplyLimit =
            args.supplyLimit == undefined
                ? undefined
                : typeof args.supplyLimit === "bigint"
                    ? args.supplyLimit
                    : BigInt(args.supplyLimit);
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => (v == undefined ? undefined : URL.parse(v)));
    }
    copy() {
        return new CreateToken(this.asObject());
    }
    asObject() {
        return {
            type: "createToken",
            url: this.url === undefined ? undefined : this.url.toString(),
            symbol: this.symbol === undefined ? undefined : this.symbol,
            precision: this.precision === undefined ? undefined : this.precision,
            properties: this.properties === undefined ? undefined : this.properties.toString(),
            supplyLimit: this.supplyLimit === undefined ? undefined : this.supplyLimit.toString(),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.toString())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], CreateToken.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], CreateToken.prototype, "url", void 0);
__decorate([
    (encodeAs.field(4).string)
], CreateToken.prototype, "symbol", void 0);
__decorate([
    (encodeAs.field(5).uint)
], CreateToken.prototype, "precision", void 0);
__decorate([
    (encodeAs.field(6).url)
], CreateToken.prototype, "properties", void 0);
__decorate([
    (encodeAs.field(7).bigInt)
], CreateToken.prototype, "supplyLimit", void 0);
__decorate([
    (encodeAs.field(9).repeatable.url)
], CreateToken.prototype, "authorities", void 0);
export class CreateTokenAccount {
    constructor(args) {
        this.type = TransactionType.CreateTokenAccount;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.tokenUrl = args.tokenUrl == undefined ? undefined : URL.parse(args.tokenUrl);
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => (v == undefined ? undefined : URL.parse(v)));
        this.proof =
            args.proof == undefined
                ? undefined
                : args.proof instanceof TokenIssuerProof
                    ? args.proof
                    : new TokenIssuerProof(args.proof);
    }
    copy() {
        return new CreateTokenAccount(this.asObject());
    }
    asObject() {
        return {
            type: "createTokenAccount",
            url: this.url === undefined ? undefined : this.url.toString(),
            tokenUrl: this.tokenUrl === undefined ? undefined : this.tokenUrl.toString(),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.toString())),
            proof: this.proof === undefined ? undefined : this.proof.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], CreateTokenAccount.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], CreateTokenAccount.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).url)
], CreateTokenAccount.prototype, "tokenUrl", void 0);
__decorate([
    (encodeAs.field(7).repeatable.url)
], CreateTokenAccount.prototype, "authorities", void 0);
__decorate([
    (encodeAs.field(8).reference)
], CreateTokenAccount.prototype, "proof", void 0);
export class CreditRecipient {
    constructor(args) {
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.amount = args.amount == undefined ? undefined : args.amount;
    }
    copy() {
        return new CreditRecipient(this.asObject());
    }
    asObject() {
        return {
            url: this.url === undefined ? undefined : this.url.toString(),
            amount: this.amount === undefined ? undefined : this.amount,
        };
    }
}
__decorate([
    (encodeAs.field(1).url)
], CreditRecipient.prototype, "url", void 0);
__decorate([
    (encodeAs.field(2).uint)
], CreditRecipient.prototype, "amount", void 0);
export class DataAccount {
    constructor(args) {
        this.type = AccountType.DataAccount;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => v == undefined ? undefined : v instanceof AuthorityEntry ? v : new AuthorityEntry(v));
        this.entry = args.entry == undefined ? undefined : DataEntry.fromObject(args.entry);
    }
    copy() {
        return new DataAccount(this.asObject());
    }
    asObject() {
        return {
            type: "dataAccount",
            url: this.url === undefined ? undefined : this.url.toString(),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.asObject())),
            entry: this.entry === undefined ? undefined : this.entry.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], DataAccount.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], DataAccount.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3, 1).repeatable.reference)
], DataAccount.prototype, "authorities", void 0);
__decorate([
    (encodeAs.field(4).union)
], DataAccount.prototype, "entry", void 0);
export class DelegatedSignature {
    constructor(args) {
        this.type = SignatureType.Delegated;
        this.signature = args.signature == undefined ? undefined : Signature.fromObject(args.signature);
        this.delegator = args.delegator == undefined ? undefined : URL.parse(args.delegator);
    }
    copy() {
        return new DelegatedSignature(this.asObject());
    }
    asObject() {
        return {
            type: "delegated",
            signature: this.signature === undefined ? undefined : this.signature.asObject(),
            delegator: this.delegator === undefined ? undefined : this.delegator.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], DelegatedSignature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).union)
], DelegatedSignature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(3).url)
], DelegatedSignature.prototype, "delegator", void 0);
export class DirectoryAnchor {
    constructor(args) {
        this.type = TransactionType.DirectoryAnchor;
        this.source = args.source == undefined ? undefined : URL.parse(args.source);
        this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
        this.minorBlockIndex = args.minorBlockIndex == undefined ? undefined : args.minorBlockIndex;
        this.rootChainIndex = args.rootChainIndex == undefined ? undefined : args.rootChainIndex;
        this.rootChainAnchor =
            args.rootChainAnchor == undefined
                ? undefined
                : args.rootChainAnchor instanceof Uint8Array
                    ? args.rootChainAnchor
                    : Buffer.from(args.rootChainAnchor, "hex");
        this.stateTreeAnchor =
            args.stateTreeAnchor == undefined
                ? undefined
                : args.stateTreeAnchor instanceof Uint8Array
                    ? args.stateTreeAnchor
                    : Buffer.from(args.stateTreeAnchor, "hex");
        this.updates =
            args.updates == undefined
                ? undefined
                : args.updates.map((v) => v == undefined
                    ? undefined
                    : v instanceof NetworkAccountUpdate
                        ? v
                        : new NetworkAccountUpdate(v));
        this.receipts =
            args.receipts == undefined
                ? undefined
                : args.receipts.map((v) => v == undefined
                    ? undefined
                    : v instanceof PartitionAnchorReceipt
                        ? v
                        : new PartitionAnchorReceipt(v));
        this.makeMajorBlock = args.makeMajorBlock == undefined ? undefined : args.makeMajorBlock;
        this.makeMajorBlockTime =
            args.makeMajorBlockTime == undefined
                ? undefined
                : args.makeMajorBlockTime instanceof Date
                    ? args.makeMajorBlockTime
                    : new Date(args.makeMajorBlockTime);
    }
    copy() {
        return new DirectoryAnchor(this.asObject());
    }
    asObject() {
        return {
            type: "directoryAnchor",
            source: this.source === undefined ? undefined : this.source.toString(),
            majorBlockIndex: this.majorBlockIndex === undefined ? undefined : this.majorBlockIndex,
            minorBlockIndex: this.minorBlockIndex === undefined ? undefined : this.minorBlockIndex,
            rootChainIndex: this.rootChainIndex === undefined ? undefined : this.rootChainIndex,
            rootChainAnchor: this.rootChainAnchor === undefined
                ? undefined
                : this.rootChainAnchor && Buffer.from(this.rootChainAnchor).toString("hex"),
            stateTreeAnchor: this.stateTreeAnchor === undefined
                ? undefined
                : this.stateTreeAnchor && Buffer.from(this.stateTreeAnchor).toString("hex"),
            updates: this.updates === undefined
                ? undefined
                : this.updates?.map((v) => (v == undefined ? undefined : v.asObject())),
            receipts: this.receipts === undefined
                ? undefined
                : this.receipts?.map((v) => (v == undefined ? undefined : v.asObject())),
            makeMajorBlock: this.makeMajorBlock === undefined ? undefined : this.makeMajorBlock,
            makeMajorBlockTime: this.makeMajorBlockTime === undefined ? undefined : this.makeMajorBlockTime,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], DirectoryAnchor.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2, 1).url)
], DirectoryAnchor.prototype, "source", void 0);
__decorate([
    (encodeAs.field(2, 2).uint)
], DirectoryAnchor.prototype, "majorBlockIndex", void 0);
__decorate([
    (encodeAs.field(2, 3).uint)
], DirectoryAnchor.prototype, "minorBlockIndex", void 0);
__decorate([
    (encodeAs.field(2, 4).uint)
], DirectoryAnchor.prototype, "rootChainIndex", void 0);
__decorate([
    (encodeAs.field(2, 5).hash)
], DirectoryAnchor.prototype, "rootChainAnchor", void 0);
__decorate([
    (encodeAs.field(2, 6).hash)
], DirectoryAnchor.prototype, "stateTreeAnchor", void 0);
__decorate([
    (encodeAs.field(3).repeatable.reference)
], DirectoryAnchor.prototype, "updates", void 0);
__decorate([
    (encodeAs.field(4).repeatable.reference)
], DirectoryAnchor.prototype, "receipts", void 0);
__decorate([
    (encodeAs.field(5).uint)
], DirectoryAnchor.prototype, "makeMajorBlock", void 0);
__decorate([
    (encodeAs.field(6).time)
], DirectoryAnchor.prototype, "makeMajorBlockTime", void 0);
export class DisableAccountAuthOperation {
    constructor(args) {
        this.type = AccountAuthOperationType.Disable;
        this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    }
    copy() {
        return new DisableAccountAuthOperation(this.asObject());
    }
    asObject() {
        return {
            type: "disable",
            authority: this.authority === undefined ? undefined : this.authority.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountAuthOperationType))
], DisableAccountAuthOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], DisableAccountAuthOperation.prototype, "authority", void 0);
export class DoubleHashDataEntry {
    constructor(args) {
        this.type = DataEntryType.DoubleHash;
        this.data =
            args.data == undefined
                ? undefined
                : args.data.map((v) => v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"));
    }
    copy() {
        return new DoubleHashDataEntry(this.asObject());
    }
    asObject() {
        return {
            type: "doubleHash",
            data: this.data === undefined
                ? undefined
                : this.data?.map((v) => v == undefined ? undefined : v && Buffer.from(v).toString("hex")),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(DataEntryType))
], DoubleHashDataEntry.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).repeatable.bytes)
], DoubleHashDataEntry.prototype, "data", void 0);
export class ED25519Signature {
    constructor(args) {
        this.type = SignatureType.ED25519;
        this.publicKey =
            args.publicKey == undefined
                ? undefined
                : args.publicKey instanceof Uint8Array
                    ? args.publicKey
                    : Buffer.from(args.publicKey, "hex");
        this.signature =
            args.signature == undefined
                ? undefined
                : args.signature instanceof Uint8Array
                    ? args.signature
                    : Buffer.from(args.signature, "hex");
        this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
        this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
        this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
        this.memo = args.memo == undefined ? undefined : args.memo;
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
    }
    copy() {
        return new ED25519Signature(this.asObject());
    }
    asObject() {
        return {
            type: "ed25519",
            publicKey: this.publicKey === undefined
                ? undefined
                : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
            signature: this.signature === undefined
                ? undefined
                : this.signature && Buffer.from(this.signature).toString("hex"),
            signer: this.signer === undefined ? undefined : this.signer.toString(),
            signerVersion: this.signerVersion === undefined ? undefined : this.signerVersion,
            timestamp: this.timestamp === undefined ? undefined : this.timestamp,
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
            memo: this.memo === undefined ? undefined : this.memo,
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], ED25519Signature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bytes)
], ED25519Signature.prototype, "publicKey", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], ED25519Signature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(4).url)
], ED25519Signature.prototype, "signer", void 0);
__decorate([
    (encodeAs.field(5).uint)
], ED25519Signature.prototype, "signerVersion", void 0);
__decorate([
    (encodeAs.field(6).uint)
], ED25519Signature.prototype, "timestamp", void 0);
__decorate([
    (encodeAs.field(7).enum)
], ED25519Signature.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(8).hash)
], ED25519Signature.prototype, "transactionHash", void 0);
__decorate([
    (encodeAs.field(9).string)
], ED25519Signature.prototype, "memo", void 0);
__decorate([
    (encodeAs.field(10).bytes)
], ED25519Signature.prototype, "data", void 0);
export class ETHSignature {
    constructor(args) {
        this.type = SignatureType.ETH;
        this.publicKey =
            args.publicKey == undefined
                ? undefined
                : args.publicKey instanceof Uint8Array
                    ? args.publicKey
                    : Buffer.from(args.publicKey, "hex");
        this.signature =
            args.signature == undefined
                ? undefined
                : args.signature instanceof Uint8Array
                    ? args.signature
                    : Buffer.from(args.signature, "hex");
        this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
        this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
        this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
        this.memo = args.memo == undefined ? undefined : args.memo;
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
    }
    copy() {
        return new ETHSignature(this.asObject());
    }
    asObject() {
        return {
            type: "eth",
            publicKey: this.publicKey === undefined
                ? undefined
                : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
            signature: this.signature === undefined
                ? undefined
                : this.signature && Buffer.from(this.signature).toString("hex"),
            signer: this.signer === undefined ? undefined : this.signer.toString(),
            signerVersion: this.signerVersion === undefined ? undefined : this.signerVersion,
            timestamp: this.timestamp === undefined ? undefined : this.timestamp,
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
            memo: this.memo === undefined ? undefined : this.memo,
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], ETHSignature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bytes)
], ETHSignature.prototype, "publicKey", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], ETHSignature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(4).url)
], ETHSignature.prototype, "signer", void 0);
__decorate([
    (encodeAs.field(5).uint)
], ETHSignature.prototype, "signerVersion", void 0);
__decorate([
    (encodeAs.field(6).uint)
], ETHSignature.prototype, "timestamp", void 0);
__decorate([
    (encodeAs.field(7).enum)
], ETHSignature.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(8).hash)
], ETHSignature.prototype, "transactionHash", void 0);
__decorate([
    (encodeAs.field(9).string)
], ETHSignature.prototype, "memo", void 0);
__decorate([
    (encodeAs.field(10).bytes)
], ETHSignature.prototype, "data", void 0);
export class EcdsaSha256Signature {
    constructor(args) {
        this.type = SignatureType.EcdsaSha256;
        this.publicKey =
            args.publicKey == undefined
                ? undefined
                : args.publicKey instanceof Uint8Array
                    ? args.publicKey
                    : Buffer.from(args.publicKey, "hex");
        this.signature =
            args.signature == undefined
                ? undefined
                : args.signature instanceof Uint8Array
                    ? args.signature
                    : Buffer.from(args.signature, "hex");
        this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
        this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
        this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
        this.memo = args.memo == undefined ? undefined : args.memo;
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
    }
    copy() {
        return new EcdsaSha256Signature(this.asObject());
    }
    asObject() {
        return {
            type: "ecdsaSha256",
            publicKey: this.publicKey === undefined
                ? undefined
                : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
            signature: this.signature === undefined
                ? undefined
                : this.signature && Buffer.from(this.signature).toString("hex"),
            signer: this.signer === undefined ? undefined : this.signer.toString(),
            signerVersion: this.signerVersion === undefined ? undefined : this.signerVersion,
            timestamp: this.timestamp === undefined ? undefined : this.timestamp,
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
            memo: this.memo === undefined ? undefined : this.memo,
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], EcdsaSha256Signature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bytes)
], EcdsaSha256Signature.prototype, "publicKey", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], EcdsaSha256Signature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(4).url)
], EcdsaSha256Signature.prototype, "signer", void 0);
__decorate([
    (encodeAs.field(5).uint)
], EcdsaSha256Signature.prototype, "signerVersion", void 0);
__decorate([
    (encodeAs.field(6).uint)
], EcdsaSha256Signature.prototype, "timestamp", void 0);
__decorate([
    (encodeAs.field(7).enum)
], EcdsaSha256Signature.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(8).hash)
], EcdsaSha256Signature.prototype, "transactionHash", void 0);
__decorate([
    (encodeAs.field(9).string)
], EcdsaSha256Signature.prototype, "memo", void 0);
__decorate([
    (encodeAs.field(10).bytes)
], EcdsaSha256Signature.prototype, "data", void 0);
export class EmptyResult {
    constructor(_) {
        this.type = TransactionType.Unknown;
    }
    copy() {
        return new EmptyResult(this.asObject());
    }
    asObject() {
        return {
            type: "unknown",
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], EmptyResult.prototype, "type", void 0);
export class EnableAccountAuthOperation {
    constructor(args) {
        this.type = AccountAuthOperationType.Enable;
        this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    }
    copy() {
        return new EnableAccountAuthOperation(this.asObject());
    }
    asObject() {
        return {
            type: "enable",
            authority: this.authority === undefined ? undefined : this.authority.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountAuthOperationType))
], EnableAccountAuthOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], EnableAccountAuthOperation.prototype, "authority", void 0);
export class ExpireOptions {
    constructor(args) {
        this.atTime =
            args.atTime == undefined
                ? undefined
                : args.atTime instanceof Date
                    ? args.atTime
                    : new Date(args.atTime);
    }
    copy() {
        return new ExpireOptions(this.asObject());
    }
    asObject() {
        return {
            atTime: this.atTime === undefined ? undefined : this.atTime,
        };
    }
}
__decorate([
    (encodeAs.field(1).time)
], ExpireOptions.prototype, "atTime", void 0);
export class FactomDataEntry {
    constructor(args) {
        this.accountId =
            args.accountId == undefined
                ? undefined
                : args.accountId instanceof Uint8Array
                    ? args.accountId
                    : Buffer.from(args.accountId, "hex");
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
        this.extIds =
            args.extIds == undefined
                ? undefined
                : args.extIds.map((v) => v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"));
    }
    copy() {
        return new FactomDataEntry(this.asObject());
    }
    asObject() {
        return {
            accountId: this.accountId === undefined
                ? undefined
                : this.accountId && Buffer.from(this.accountId).toString("hex"),
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
            extIds: this.extIds === undefined
                ? undefined
                : this.extIds?.map((v) => v == undefined ? undefined : v && Buffer.from(v).toString("hex")),
        };
    }
}
export class FactomDataEntryWrapper {
    constructor(args) {
        this.type = DataEntryType.Factom;
        this.accountId =
            args.accountId == undefined
                ? undefined
                : args.accountId instanceof Uint8Array
                    ? args.accountId
                    : Buffer.from(args.accountId, "hex");
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
        this.extIds =
            args.extIds == undefined
                ? undefined
                : args.extIds.map((v) => v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"));
    }
    copy() {
        return new FactomDataEntryWrapper(this.asObject());
    }
    asObject() {
        return {
            type: "factom",
            accountId: this.accountId === undefined
                ? undefined
                : this.accountId && Buffer.from(this.accountId).toString("hex"),
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
            extIds: this.extIds === undefined
                ? undefined
                : this.extIds?.map((v) => v == undefined ? undefined : v && Buffer.from(v).toString("hex")),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(DataEntryType))
], FactomDataEntryWrapper.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2, 1).hash)
], FactomDataEntryWrapper.prototype, "accountId", void 0);
__decorate([
    (encodeAs.field(2, 2).bytes)
], FactomDataEntryWrapper.prototype, "data", void 0);
__decorate([
    (encodeAs.field(2, 3).repeatable.bytes)
], FactomDataEntryWrapper.prototype, "extIds", void 0);
export class FeeSchedule {
    constructor(args) {
        this.createIdentitySliding =
            args.createIdentitySliding == undefined
                ? undefined
                : args.createIdentitySliding.map((v) => (v == undefined ? undefined : getFeeClass().fromObject(v)));
        this.createSubIdentity =
            args.createSubIdentity == undefined ? undefined : getFeeClass().fromObject(args.createSubIdentity);
        this.bareIdentityDiscount =
            args.bareIdentityDiscount == undefined
                ? undefined
                : getFeeClass().fromObject(args.bareIdentityDiscount);
    }
    copy() {
        return new FeeSchedule(this.asObject());
    }
    asObject() {
        return {
            createIdentitySliding: this.createIdentitySliding === undefined
                ? undefined
                : this.createIdentitySliding?.map((v) => (v == undefined ? undefined : getFeeClass().getName(v))),
            createSubIdentity: this.createSubIdentity === undefined ? undefined : getFeeClass().getName(this.createSubIdentity),
            bareIdentityDiscount: this.bareIdentityDiscount === undefined
                ? undefined
                : getFeeClass().getName(this.bareIdentityDiscount),
        };
    }
}
__decorate([
    (encodeAs.field(1).repeatable.enum)
], FeeSchedule.prototype, "createIdentitySliding", void 0);
__decorate([
    (encodeAs.field(2).enum)
], FeeSchedule.prototype, "createSubIdentity", void 0);
__decorate([
    (encodeAs.field(3).enum)
], FeeSchedule.prototype, "bareIdentityDiscount", void 0);
export class HoldUntilOptions {
    constructor(args) {
        this.minorBlock = args.minorBlock == undefined ? undefined : args.minorBlock;
    }
    copy() {
        return new HoldUntilOptions(this.asObject());
    }
    asObject() {
        return {
            minorBlock: this.minorBlock === undefined ? undefined : this.minorBlock,
        };
    }
}
__decorate([
    (encodeAs.field(1).uint)
], HoldUntilOptions.prototype, "minorBlock", void 0);
export class IndexEntry {
    constructor(args) {
        this.source = args.source == undefined ? undefined : args.source;
        this.anchor = args.anchor == undefined ? undefined : args.anchor;
        this.blockIndex = args.blockIndex == undefined ? undefined : args.blockIndex;
        this.blockTime =
            args.blockTime == undefined
                ? undefined
                : args.blockTime instanceof Date
                    ? args.blockTime
                    : new Date(args.blockTime);
        this.rootIndexIndex = args.rootIndexIndex == undefined ? undefined : args.rootIndexIndex;
    }
    copy() {
        return new IndexEntry(this.asObject());
    }
    asObject() {
        return {
            source: this.source === undefined ? undefined : this.source,
            anchor: this.anchor === undefined ? undefined : this.anchor,
            blockIndex: this.blockIndex === undefined ? undefined : this.blockIndex,
            blockTime: this.blockTime === undefined ? undefined : this.blockTime,
            rootIndexIndex: this.rootIndexIndex === undefined ? undefined : this.rootIndexIndex,
        };
    }
}
__decorate([
    (encodeAs.field(1).uint)
], IndexEntry.prototype, "source", void 0);
__decorate([
    (encodeAs.field(2).uint)
], IndexEntry.prototype, "anchor", void 0);
__decorate([
    (encodeAs.field(3).uint)
], IndexEntry.prototype, "blockIndex", void 0);
__decorate([
    (encodeAs.field(4).time)
], IndexEntry.prototype, "blockTime", void 0);
__decorate([
    (encodeAs.field(5).uint)
], IndexEntry.prototype, "rootIndexIndex", void 0);
export class InternalSignature {
    constructor(args) {
        this.type = SignatureType.Internal;
        this.cause =
            args.cause == undefined
                ? undefined
                : args.cause instanceof Uint8Array
                    ? args.cause
                    : Buffer.from(args.cause, "hex");
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
    }
    copy() {
        return new InternalSignature(this.asObject());
    }
    asObject() {
        return {
            type: "internal",
            cause: this.cause === undefined
                ? undefined
                : this.cause && Buffer.from(this.cause).toString("hex"),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], InternalSignature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).hash)
], InternalSignature.prototype, "cause", void 0);
__decorate([
    (encodeAs.field(3).hash)
], InternalSignature.prototype, "transactionHash", void 0);
export class IssueTokens {
    constructor(args) {
        this.type = TransactionType.IssueTokens;
        this.recipient = args.recipient == undefined ? undefined : URL.parse(args.recipient);
        this.amount =
            args.amount == undefined
                ? undefined
                : typeof args.amount === "bigint"
                    ? args.amount
                    : BigInt(args.amount);
        this.to =
            args.to == undefined
                ? undefined
                : args.to.map((v) => v == undefined ? undefined : v instanceof TokenRecipient ? v : new TokenRecipient(v));
    }
    copy() {
        return new IssueTokens(this.asObject());
    }
    asObject() {
        return {
            type: "issueTokens",
            recipient: this.recipient === undefined ? undefined : this.recipient.toString(),
            amount: this.amount === undefined ? undefined : this.amount.toString(),
            to: this.to === undefined
                ? undefined
                : this.to?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], IssueTokens.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], IssueTokens.prototype, "recipient", void 0);
__decorate([
    (encodeAs.field(3).bigInt)
], IssueTokens.prototype, "amount", void 0);
__decorate([
    (encodeAs.field(4).repeatable.reference)
], IssueTokens.prototype, "to", void 0);
export class KeyBook {
    constructor(args) {
        this.type = AccountType.KeyBook;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.bookType = args.bookType == undefined ? undefined : BookType.fromObject(args.bookType);
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => v == undefined ? undefined : v instanceof AuthorityEntry ? v : new AuthorityEntry(v));
        this.pageCount = args.pageCount == undefined ? undefined : args.pageCount;
    }
    copy() {
        return new KeyBook(this.asObject());
    }
    asObject() {
        return {
            type: "keyBook",
            url: this.url === undefined ? undefined : this.url.toString(),
            bookType: this.bookType === undefined ? undefined : BookType.getName(this.bookType),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.asObject())),
            pageCount: this.pageCount === undefined ? undefined : this.pageCount,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], KeyBook.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], KeyBook.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).enum)
], KeyBook.prototype, "bookType", void 0);
__decorate([
    (encodeAs.field(4, 1).repeatable.reference)
], KeyBook.prototype, "authorities", void 0);
__decorate([
    (encodeAs.field(5).uint)
], KeyBook.prototype, "pageCount", void 0);
export class KeyPage {
    constructor(args) {
        this.type = AccountType.KeyPage;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.creditBalance = args.creditBalance == undefined ? undefined : args.creditBalance;
        this.acceptThreshold = args.acceptThreshold == undefined ? undefined : args.acceptThreshold;
        this.rejectThreshold = args.rejectThreshold == undefined ? undefined : args.rejectThreshold;
        this.responseThreshold =
            args.responseThreshold == undefined ? undefined : args.responseThreshold;
        this.blockThreshold = args.blockThreshold == undefined ? undefined : args.blockThreshold;
        this.version = args.version == undefined ? undefined : args.version;
        this.keys =
            args.keys == undefined
                ? undefined
                : args.keys.map((v) => v == undefined ? undefined : v instanceof KeySpec ? v : new KeySpec(v));
        this.transactionBlacklist =
            args.transactionBlacklist == undefined
                ? undefined
                : getAllowedTransactionsClass().fromObject(args.transactionBlacklist);
    }
    copy() {
        return new KeyPage(this.asObject());
    }
    asObject() {
        return {
            type: "keyPage",
            url: this.url === undefined ? undefined : this.url.toString(),
            creditBalance: this.creditBalance === undefined ? undefined : this.creditBalance,
            acceptThreshold: this.acceptThreshold === undefined ? undefined : this.acceptThreshold,
            rejectThreshold: this.rejectThreshold === undefined ? undefined : this.rejectThreshold,
            responseThreshold: this.responseThreshold === undefined ? undefined : this.responseThreshold,
            blockThreshold: this.blockThreshold === undefined ? undefined : this.blockThreshold,
            version: this.version === undefined ? undefined : this.version,
            keys: this.keys === undefined
                ? undefined
                : this.keys?.map((v) => (v == undefined ? undefined : v.asObject())),
            transactionBlacklist: this.transactionBlacklist === undefined
                ? undefined
                : this.transactionBlacklist.map((v) => TransactionType.getName(v)),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], KeyPage.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], KeyPage.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).uint)
], KeyPage.prototype, "creditBalance", void 0);
__decorate([
    (encodeAs.field(4).uint)
], KeyPage.prototype, "acceptThreshold", void 0);
__decorate([
    (encodeAs.field(5).uint)
], KeyPage.prototype, "rejectThreshold", void 0);
__decorate([
    (encodeAs.field(6).uint)
], KeyPage.prototype, "responseThreshold", void 0);
__decorate([
    (encodeAs.field(7).uint)
], KeyPage.prototype, "blockThreshold", void 0);
__decorate([
    (encodeAs.field(8).uint)
], KeyPage.prototype, "version", void 0);
__decorate([
    (encodeAs.field(9).repeatable.reference)
], KeyPage.prototype, "keys", void 0);
__decorate([
    (encodeAs.field(10).enum)
], KeyPage.prototype, "transactionBlacklist", void 0);
export class KeySpec {
    constructor(args) {
        this.publicKeyHash =
            args.publicKeyHash == undefined
                ? undefined
                : args.publicKeyHash instanceof Uint8Array
                    ? args.publicKeyHash
                    : Buffer.from(args.publicKeyHash, "hex");
        this.lastUsedOn = args.lastUsedOn == undefined ? undefined : args.lastUsedOn;
        this.delegate = args.delegate == undefined ? undefined : URL.parse(args.delegate);
    }
    copy() {
        return new KeySpec(this.asObject());
    }
    asObject() {
        return {
            publicKeyHash: this.publicKeyHash === undefined
                ? undefined
                : this.publicKeyHash && Buffer.from(this.publicKeyHash).toString("hex"),
            lastUsedOn: this.lastUsedOn === undefined ? undefined : this.lastUsedOn,
            delegate: this.delegate === undefined ? undefined : this.delegate.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).bytes)
], KeySpec.prototype, "publicKeyHash", void 0);
__decorate([
    (encodeAs.field(2).uint)
], KeySpec.prototype, "lastUsedOn", void 0);
__decorate([
    (encodeAs.field(3).url)
], KeySpec.prototype, "delegate", void 0);
export class KeySpecParams {
    constructor(args) {
        this.keyHash =
            args.keyHash == undefined
                ? undefined
                : args.keyHash instanceof Uint8Array
                    ? args.keyHash
                    : Buffer.from(args.keyHash, "hex");
        this.delegate = args.delegate == undefined ? undefined : URL.parse(args.delegate);
    }
    copy() {
        return new KeySpecParams(this.asObject());
    }
    asObject() {
        return {
            keyHash: this.keyHash === undefined
                ? undefined
                : this.keyHash && Buffer.from(this.keyHash).toString("hex"),
            delegate: this.delegate === undefined ? undefined : this.delegate.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).bytes)
], KeySpecParams.prototype, "keyHash", void 0);
__decorate([
    (encodeAs.field(2).url)
], KeySpecParams.prototype, "delegate", void 0);
export class LegacyED25519Signature {
    constructor(args) {
        this.type = SignatureType.LegacyED25519;
        this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
        this.publicKey =
            args.publicKey == undefined
                ? undefined
                : args.publicKey instanceof Uint8Array
                    ? args.publicKey
                    : Buffer.from(args.publicKey, "hex");
        this.signature =
            args.signature == undefined
                ? undefined
                : args.signature instanceof Uint8Array
                    ? args.signature
                    : Buffer.from(args.signature, "hex");
        this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
        this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
    }
    copy() {
        return new LegacyED25519Signature(this.asObject());
    }
    asObject() {
        return {
            type: "legacyED25519",
            timestamp: this.timestamp === undefined ? undefined : this.timestamp,
            publicKey: this.publicKey === undefined
                ? undefined
                : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
            signature: this.signature === undefined
                ? undefined
                : this.signature && Buffer.from(this.signature).toString("hex"),
            signer: this.signer === undefined ? undefined : this.signer.toString(),
            signerVersion: this.signerVersion === undefined ? undefined : this.signerVersion,
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], LegacyED25519Signature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).uint)
], LegacyED25519Signature.prototype, "timestamp", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], LegacyED25519Signature.prototype, "publicKey", void 0);
__decorate([
    (encodeAs.field(4).bytes)
], LegacyED25519Signature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(5).url)
], LegacyED25519Signature.prototype, "signer", void 0);
__decorate([
    (encodeAs.field(6).uint)
], LegacyED25519Signature.prototype, "signerVersion", void 0);
__decorate([
    (encodeAs.field(7).enum)
], LegacyED25519Signature.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(8).hash)
], LegacyED25519Signature.prototype, "transactionHash", void 0);
export class LiteDataAccount {
    constructor(args) {
        this.type = AccountType.LiteDataAccount;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
    }
    copy() {
        return new LiteDataAccount(this.asObject());
    }
    asObject() {
        return {
            type: "liteDataAccount",
            url: this.url === undefined ? undefined : this.url.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], LiteDataAccount.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], LiteDataAccount.prototype, "url", void 0);
export class LiteIdentity {
    constructor(args) {
        this.type = AccountType.LiteIdentity;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.creditBalance = args.creditBalance == undefined ? undefined : args.creditBalance;
        this.lastUsedOn = args.lastUsedOn == undefined ? undefined : args.lastUsedOn;
    }
    copy() {
        return new LiteIdentity(this.asObject());
    }
    asObject() {
        return {
            type: "liteIdentity",
            url: this.url === undefined ? undefined : this.url.toString(),
            creditBalance: this.creditBalance === undefined ? undefined : this.creditBalance,
            lastUsedOn: this.lastUsedOn === undefined ? undefined : this.lastUsedOn,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], LiteIdentity.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], LiteIdentity.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).uint)
], LiteIdentity.prototype, "creditBalance", void 0);
__decorate([
    (encodeAs.field(4).uint)
], LiteIdentity.prototype, "lastUsedOn", void 0);
export class LiteTokenAccount {
    constructor(args) {
        this.type = AccountType.LiteTokenAccount;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.tokenUrl = args.tokenUrl == undefined ? undefined : URL.parse(args.tokenUrl);
        this.balance =
            args.balance == undefined
                ? undefined
                : typeof args.balance === "bigint"
                    ? args.balance
                    : BigInt(args.balance);
        this.lockHeight = args.lockHeight == undefined ? undefined : args.lockHeight;
    }
    copy() {
        return new LiteTokenAccount(this.asObject());
    }
    asObject() {
        return {
            type: "liteTokenAccount",
            url: this.url === undefined ? undefined : this.url.toString(),
            tokenUrl: this.tokenUrl === undefined ? undefined : this.tokenUrl.toString(),
            balance: this.balance === undefined ? undefined : this.balance.toString(),
            lockHeight: this.lockHeight === undefined ? undefined : this.lockHeight,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], LiteTokenAccount.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], LiteTokenAccount.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).url)
], LiteTokenAccount.prototype, "tokenUrl", void 0);
__decorate([
    (encodeAs.field(4).bigInt)
], LiteTokenAccount.prototype, "balance", void 0);
__decorate([
    (encodeAs.field(5).uint)
], LiteTokenAccount.prototype, "lockHeight", void 0);
export class LockAccount {
    constructor(args) {
        this.type = TransactionType.LockAccount;
        this.height = args.height == undefined ? undefined : args.height;
    }
    copy() {
        return new LockAccount(this.asObject());
    }
    asObject() {
        return {
            type: "lockAccount",
            height: this.height === undefined ? undefined : this.height,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], LockAccount.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).uint)
], LockAccount.prototype, "height", void 0);
export class NetworkAccountUpdate {
    constructor(args) {
        this.name = args.name == undefined ? undefined : args.name;
        this.body = args.body == undefined ? undefined : TransactionBody.fromObject(args.body);
    }
    copy() {
        return new NetworkAccountUpdate(this.asObject());
    }
    asObject() {
        return {
            name: this.name === undefined ? undefined : this.name,
            body: this.body === undefined ? undefined : this.body.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).string)
], NetworkAccountUpdate.prototype, "name", void 0);
__decorate([
    (encodeAs.field(2).union)
], NetworkAccountUpdate.prototype, "body", void 0);
export class NetworkDefinition {
    constructor(args) {
        this.networkName = args.networkName == undefined ? undefined : args.networkName;
        this.version = args.version == undefined ? undefined : args.version;
        this.partitions =
            args.partitions == undefined
                ? undefined
                : args.partitions.map((v) => v == undefined ? undefined : v instanceof PartitionInfo ? v : new PartitionInfo(v));
        this.validators =
            args.validators == undefined
                ? undefined
                : args.validators.map((v) => v == undefined ? undefined : v instanceof ValidatorInfo ? v : new ValidatorInfo(v));
    }
    copy() {
        return new NetworkDefinition(this.asObject());
    }
    asObject() {
        return {
            networkName: this.networkName === undefined ? undefined : this.networkName,
            version: this.version === undefined ? undefined : this.version,
            partitions: this.partitions === undefined
                ? undefined
                : this.partitions?.map((v) => (v == undefined ? undefined : v.asObject())),
            validators: this.validators === undefined
                ? undefined
                : this.validators?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).string)
], NetworkDefinition.prototype, "networkName", void 0);
__decorate([
    (encodeAs.field(2).uint)
], NetworkDefinition.prototype, "version", void 0);
__decorate([
    (encodeAs.field(3).repeatable.reference)
], NetworkDefinition.prototype, "partitions", void 0);
__decorate([
    (encodeAs.field(4).repeatable.reference)
], NetworkDefinition.prototype, "validators", void 0);
export class NetworkGlobals {
    constructor(args) {
        this.operatorAcceptThreshold =
            args.operatorAcceptThreshold == undefined
                ? undefined
                : args.operatorAcceptThreshold instanceof Rational
                    ? args.operatorAcceptThreshold
                    : new Rational(args.operatorAcceptThreshold);
        this.validatorAcceptThreshold =
            args.validatorAcceptThreshold == undefined
                ? undefined
                : args.validatorAcceptThreshold instanceof Rational
                    ? args.validatorAcceptThreshold
                    : new Rational(args.validatorAcceptThreshold);
        this.majorBlockSchedule =
            args.majorBlockSchedule == undefined ? undefined : args.majorBlockSchedule;
        this.anchorEmptyBlocks =
            args.anchorEmptyBlocks == undefined ? undefined : args.anchorEmptyBlocks;
        this.feeSchedule =
            args.feeSchedule == undefined
                ? undefined
                : args.feeSchedule instanceof FeeSchedule
                    ? args.feeSchedule
                    : new FeeSchedule(args.feeSchedule);
        this.limits =
            args.limits == undefined
                ? undefined
                : args.limits instanceof NetworkLimits
                    ? args.limits
                    : new NetworkLimits(args.limits);
    }
    copy() {
        return new NetworkGlobals(this.asObject());
    }
    asObject() {
        return {
            operatorAcceptThreshold: this.operatorAcceptThreshold === undefined
                ? undefined
                : this.operatorAcceptThreshold.asObject(),
            validatorAcceptThreshold: this.validatorAcceptThreshold === undefined
                ? undefined
                : this.validatorAcceptThreshold.asObject(),
            majorBlockSchedule: this.majorBlockSchedule === undefined ? undefined : this.majorBlockSchedule,
            anchorEmptyBlocks: this.anchorEmptyBlocks === undefined ? undefined : this.anchorEmptyBlocks,
            feeSchedule: this.feeSchedule === undefined ? undefined : this.feeSchedule.asObject(),
            limits: this.limits === undefined ? undefined : this.limits.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).reference)
], NetworkGlobals.prototype, "operatorAcceptThreshold", void 0);
__decorate([
    (encodeAs.field(2).reference)
], NetworkGlobals.prototype, "validatorAcceptThreshold", void 0);
__decorate([
    (encodeAs.field(3).string)
], NetworkGlobals.prototype, "majorBlockSchedule", void 0);
__decorate([
    (encodeAs.field(4).bool)
], NetworkGlobals.prototype, "anchorEmptyBlocks", void 0);
__decorate([
    (encodeAs.field(5).reference)
], NetworkGlobals.prototype, "feeSchedule", void 0);
__decorate([
    (encodeAs.field(6).reference)
], NetworkGlobals.prototype, "limits", void 0);
export class NetworkLimits {
    constructor(args) {
        this.dataEntryParts = args.dataEntryParts == undefined ? undefined : args.dataEntryParts;
        this.accountAuthorities =
            args.accountAuthorities == undefined ? undefined : args.accountAuthorities;
        this.bookPages = args.bookPages == undefined ? undefined : args.bookPages;
        this.pageEntries = args.pageEntries == undefined ? undefined : args.pageEntries;
        this.identityAccounts = args.identityAccounts == undefined ? undefined : args.identityAccounts;
        this.pendingMajorBlocks =
            args.pendingMajorBlocks == undefined ? undefined : args.pendingMajorBlocks;
        this.eventsPerBlock = args.eventsPerBlock == undefined ? undefined : args.eventsPerBlock;
    }
    copy() {
        return new NetworkLimits(this.asObject());
    }
    asObject() {
        return {
            dataEntryParts: this.dataEntryParts === undefined ? undefined : this.dataEntryParts,
            accountAuthorities: this.accountAuthorities === undefined ? undefined : this.accountAuthorities,
            bookPages: this.bookPages === undefined ? undefined : this.bookPages,
            pageEntries: this.pageEntries === undefined ? undefined : this.pageEntries,
            identityAccounts: this.identityAccounts === undefined ? undefined : this.identityAccounts,
            pendingMajorBlocks: this.pendingMajorBlocks === undefined ? undefined : this.pendingMajorBlocks,
            eventsPerBlock: this.eventsPerBlock === undefined ? undefined : this.eventsPerBlock,
        };
    }
}
__decorate([
    (encodeAs.field(1).uint)
], NetworkLimits.prototype, "dataEntryParts", void 0);
__decorate([
    (encodeAs.field(2).uint)
], NetworkLimits.prototype, "accountAuthorities", void 0);
__decorate([
    (encodeAs.field(3).uint)
], NetworkLimits.prototype, "bookPages", void 0);
__decorate([
    (encodeAs.field(4).uint)
], NetworkLimits.prototype, "pageEntries", void 0);
__decorate([
    (encodeAs.field(5).uint)
], NetworkLimits.prototype, "identityAccounts", void 0);
__decorate([
    (encodeAs.field(6).uint)
], NetworkLimits.prototype, "pendingMajorBlocks", void 0);
__decorate([
    (encodeAs.field(7).uint)
], NetworkLimits.prototype, "eventsPerBlock", void 0);
export class NetworkMaintenance {
    constructor(args) {
        this.type = TransactionType.NetworkMaintenance;
        this.operations =
            args.operations == undefined
                ? undefined
                : args.operations.map((v) => v == undefined ? undefined : NetworkMaintenanceOperation.fromObject(v));
    }
    copy() {
        return new NetworkMaintenance(this.asObject());
    }
    asObject() {
        return {
            type: "networkMaintenance",
            operations: this.operations === undefined
                ? undefined
                : this.operations?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], NetworkMaintenance.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).repeatable.union)
], NetworkMaintenance.prototype, "operations", void 0);
export class PartitionAnchor {
    constructor(args) {
        this.source = args.source == undefined ? undefined : URL.parse(args.source);
        this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
        this.minorBlockIndex = args.minorBlockIndex == undefined ? undefined : args.minorBlockIndex;
        this.rootChainIndex = args.rootChainIndex == undefined ? undefined : args.rootChainIndex;
        this.rootChainAnchor =
            args.rootChainAnchor == undefined
                ? undefined
                : args.rootChainAnchor instanceof Uint8Array
                    ? args.rootChainAnchor
                    : Buffer.from(args.rootChainAnchor, "hex");
        this.stateTreeAnchor =
            args.stateTreeAnchor == undefined
                ? undefined
                : args.stateTreeAnchor instanceof Uint8Array
                    ? args.stateTreeAnchor
                    : Buffer.from(args.stateTreeAnchor, "hex");
    }
    copy() {
        return new PartitionAnchor(this.asObject());
    }
    asObject() {
        return {
            source: this.source === undefined ? undefined : this.source.toString(),
            majorBlockIndex: this.majorBlockIndex === undefined ? undefined : this.majorBlockIndex,
            minorBlockIndex: this.minorBlockIndex === undefined ? undefined : this.minorBlockIndex,
            rootChainIndex: this.rootChainIndex === undefined ? undefined : this.rootChainIndex,
            rootChainAnchor: this.rootChainAnchor === undefined
                ? undefined
                : this.rootChainAnchor && Buffer.from(this.rootChainAnchor).toString("hex"),
            stateTreeAnchor: this.stateTreeAnchor === undefined
                ? undefined
                : this.stateTreeAnchor && Buffer.from(this.stateTreeAnchor).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).url)
], PartitionAnchor.prototype, "source", void 0);
__decorate([
    (encodeAs.field(2).uint)
], PartitionAnchor.prototype, "majorBlockIndex", void 0);
__decorate([
    (encodeAs.field(3).uint)
], PartitionAnchor.prototype, "minorBlockIndex", void 0);
__decorate([
    (encodeAs.field(4).uint)
], PartitionAnchor.prototype, "rootChainIndex", void 0);
__decorate([
    (encodeAs.field(5).hash)
], PartitionAnchor.prototype, "rootChainAnchor", void 0);
__decorate([
    (encodeAs.field(6).hash)
], PartitionAnchor.prototype, "stateTreeAnchor", void 0);
export class PartitionAnchorReceipt {
    constructor(args) {
        this.anchor =
            args.anchor == undefined
                ? undefined
                : args.anchor instanceof PartitionAnchor
                    ? args.anchor
                    : new PartitionAnchor(args.anchor);
        this.rootChainReceipt =
            args.rootChainReceipt == undefined
                ? undefined
                : args.rootChainReceipt instanceof merkle.Receipt
                    ? args.rootChainReceipt
                    : new merkle.Receipt(args.rootChainReceipt);
    }
    copy() {
        return new PartitionAnchorReceipt(this.asObject());
    }
    asObject() {
        return {
            anchor: this.anchor === undefined ? undefined : this.anchor.asObject(),
            rootChainReceipt: this.rootChainReceipt === undefined ? undefined : this.rootChainReceipt.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).reference)
], PartitionAnchorReceipt.prototype, "anchor", void 0);
__decorate([
    (encodeAs.field(2).reference)
], PartitionAnchorReceipt.prototype, "rootChainReceipt", void 0);
export class PartitionExecutorVersion {
    constructor(args) {
        this.partition = args.partition == undefined ? undefined : args.partition;
        this.version = args.version == undefined ? undefined : ExecutorVersion.fromObject(args.version);
    }
    copy() {
        return new PartitionExecutorVersion(this.asObject());
    }
    asObject() {
        return {
            partition: this.partition === undefined ? undefined : this.partition,
            version: this.version === undefined ? undefined : ExecutorVersion.getName(this.version),
        };
    }
}
__decorate([
    (encodeAs.field(1).string)
], PartitionExecutorVersion.prototype, "partition", void 0);
__decorate([
    (encodeAs.field(2).enum)
], PartitionExecutorVersion.prototype, "version", void 0);
export class PartitionInfo {
    constructor(args) {
        this.id = args.id == undefined ? undefined : args.id;
        this.type = args.type == undefined ? undefined : PartitionType.fromObject(args.type);
    }
    copy() {
        return new PartitionInfo(this.asObject());
    }
    asObject() {
        return {
            id: this.id === undefined ? undefined : this.id,
            type: this.type === undefined ? undefined : PartitionType.getName(this.type),
        };
    }
}
__decorate([
    (encodeAs.field(1).string)
], PartitionInfo.prototype, "id", void 0);
__decorate([
    (encodeAs.field(2).enum)
], PartitionInfo.prototype, "type", void 0);
export class PartitionSignature {
    constructor(args) {
        this.type = SignatureType.Partition;
        this.sourceNetwork =
            args.sourceNetwork == undefined ? undefined : URL.parse(args.sourceNetwork);
        this.destinationNetwork =
            args.destinationNetwork == undefined ? undefined : URL.parse(args.destinationNetwork);
        this.sequenceNumber = args.sequenceNumber == undefined ? undefined : args.sequenceNumber;
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
    }
    copy() {
        return new PartitionSignature(this.asObject());
    }
    asObject() {
        return {
            type: "partition",
            sourceNetwork: this.sourceNetwork === undefined ? undefined : this.sourceNetwork.toString(),
            destinationNetwork: this.destinationNetwork === undefined ? undefined : this.destinationNetwork.toString(),
            sequenceNumber: this.sequenceNumber === undefined ? undefined : this.sequenceNumber,
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], PartitionSignature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], PartitionSignature.prototype, "sourceNetwork", void 0);
__decorate([
    (encodeAs.field(3).url)
], PartitionSignature.prototype, "destinationNetwork", void 0);
__decorate([
    (encodeAs.field(4).uint)
], PartitionSignature.prototype, "sequenceNumber", void 0);
__decorate([
    (encodeAs.field(5).hash)
], PartitionSignature.prototype, "transactionHash", void 0);
export class PartitionSyntheticLedger {
    constructor(args) {
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.produced = args.produced == undefined ? undefined : args.produced;
        this.received = args.received == undefined ? undefined : args.received;
        this.delivered = args.delivered == undefined ? undefined : args.delivered;
        this.pending =
            args.pending == undefined
                ? undefined
                : args.pending.map((v) => (v == undefined ? undefined : TxID.parse(v)));
    }
    copy() {
        return new PartitionSyntheticLedger(this.asObject());
    }
    asObject() {
        return {
            url: this.url === undefined ? undefined : this.url.toString(),
            produced: this.produced === undefined ? undefined : this.produced,
            received: this.received === undefined ? undefined : this.received,
            delivered: this.delivered === undefined ? undefined : this.delivered,
            pending: this.pending === undefined
                ? undefined
                : this.pending?.map((v) => (v == undefined ? undefined : v.toString())),
        };
    }
}
__decorate([
    (encodeAs.field(1).url)
], PartitionSyntheticLedger.prototype, "url", void 0);
__decorate([
    (encodeAs.field(2).uint)
], PartitionSyntheticLedger.prototype, "produced", void 0);
__decorate([
    (encodeAs.field(3).uint)
], PartitionSyntheticLedger.prototype, "received", void 0);
__decorate([
    (encodeAs.field(4).uint)
], PartitionSyntheticLedger.prototype, "delivered", void 0);
__decorate([
    (encodeAs.field(5).repeatable.txid)
], PartitionSyntheticLedger.prototype, "pending", void 0);
export class PendingTransactionGCOperation {
    constructor(args) {
        this.type = NetworkMaintenanceOperationType.PendingTransactionGC;
        this.account = args.account == undefined ? undefined : URL.parse(args.account);
    }
    copy() {
        return new PendingTransactionGCOperation(this.asObject());
    }
    asObject() {
        return {
            type: "pendingTransactionGC",
            account: this.account === undefined ? undefined : this.account.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(NetworkMaintenanceOperationType))
], PendingTransactionGCOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], PendingTransactionGCOperation.prototype, "account", void 0);
export class RCD1Signature {
    constructor(args) {
        this.type = SignatureType.RCD1;
        this.publicKey =
            args.publicKey == undefined
                ? undefined
                : args.publicKey instanceof Uint8Array
                    ? args.publicKey
                    : Buffer.from(args.publicKey, "hex");
        this.signature =
            args.signature == undefined
                ? undefined
                : args.signature instanceof Uint8Array
                    ? args.signature
                    : Buffer.from(args.signature, "hex");
        this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
        this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
        this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
        this.memo = args.memo == undefined ? undefined : args.memo;
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
    }
    copy() {
        return new RCD1Signature(this.asObject());
    }
    asObject() {
        return {
            type: "rcd1",
            publicKey: this.publicKey === undefined
                ? undefined
                : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
            signature: this.signature === undefined
                ? undefined
                : this.signature && Buffer.from(this.signature).toString("hex"),
            signer: this.signer === undefined ? undefined : this.signer.toString(),
            signerVersion: this.signerVersion === undefined ? undefined : this.signerVersion,
            timestamp: this.timestamp === undefined ? undefined : this.timestamp,
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
            memo: this.memo === undefined ? undefined : this.memo,
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], RCD1Signature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bytes)
], RCD1Signature.prototype, "publicKey", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], RCD1Signature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(4).url)
], RCD1Signature.prototype, "signer", void 0);
__decorate([
    (encodeAs.field(5).uint)
], RCD1Signature.prototype, "signerVersion", void 0);
__decorate([
    (encodeAs.field(6).uint)
], RCD1Signature.prototype, "timestamp", void 0);
__decorate([
    (encodeAs.field(7).enum)
], RCD1Signature.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(8).hash)
], RCD1Signature.prototype, "transactionHash", void 0);
__decorate([
    (encodeAs.field(9).string)
], RCD1Signature.prototype, "memo", void 0);
__decorate([
    (encodeAs.field(10).bytes)
], RCD1Signature.prototype, "data", void 0);
export class Rational {
    constructor(args) {
        this.numerator = args.numerator == undefined ? undefined : args.numerator;
        this.denominator = args.denominator == undefined ? undefined : args.denominator;
    }
    copy() {
        return new Rational(this.asObject());
    }
    asObject() {
        return {
            numerator: this.numerator === undefined ? undefined : this.numerator,
            denominator: this.denominator === undefined ? undefined : this.denominator,
        };
    }
}
__decorate([
    (encodeAs.field(1).uint)
], Rational.prototype, "numerator", void 0);
__decorate([
    (encodeAs.field(2).uint)
], Rational.prototype, "denominator", void 0);
export class ReceiptSignature {
    constructor(args) {
        this.type = SignatureType.Receipt;
        this.sourceNetwork =
            args.sourceNetwork == undefined ? undefined : URL.parse(args.sourceNetwork);
        this.proof =
            args.proof == undefined
                ? undefined
                : args.proof instanceof merkle.Receipt
                    ? args.proof
                    : new merkle.Receipt(args.proof);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
    }
    copy() {
        return new ReceiptSignature(this.asObject());
    }
    asObject() {
        return {
            type: "receipt",
            sourceNetwork: this.sourceNetwork === undefined ? undefined : this.sourceNetwork.toString(),
            proof: this.proof === undefined ? undefined : this.proof.asObject(),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], ReceiptSignature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], ReceiptSignature.prototype, "sourceNetwork", void 0);
__decorate([
    (encodeAs.field(3).reference)
], ReceiptSignature.prototype, "proof", void 0);
__decorate([
    (encodeAs.field(4).hash)
], ReceiptSignature.prototype, "transactionHash", void 0);
export class RemoteSignature {
    constructor(args) {
        this.type = SignatureType.Remote;
        this.destination = args.destination == undefined ? undefined : URL.parse(args.destination);
        this.signature = args.signature == undefined ? undefined : Signature.fromObject(args.signature);
        this.cause =
            args.cause == undefined
                ? undefined
                : args.cause.map((v) => v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"));
    }
    copy() {
        return new RemoteSignature(this.asObject());
    }
    asObject() {
        return {
            type: "remote",
            destination: this.destination === undefined ? undefined : this.destination.toString(),
            signature: this.signature === undefined ? undefined : this.signature.asObject(),
            cause: this.cause === undefined
                ? undefined
                : this.cause?.map((v) => v == undefined ? undefined : v && Buffer.from(v).toString("hex")),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], RemoteSignature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], RemoteSignature.prototype, "destination", void 0);
__decorate([
    (encodeAs.field(3).union)
], RemoteSignature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(4).repeatable.hash)
], RemoteSignature.prototype, "cause", void 0);
export class RemoteTransaction {
    constructor(args) {
        this.type = TransactionType.Remote;
        this.hash =
            args.hash == undefined
                ? undefined
                : args.hash instanceof Uint8Array
                    ? args.hash
                    : Buffer.from(args.hash, "hex");
    }
    copy() {
        return new RemoteTransaction(this.asObject());
    }
    asObject() {
        return {
            type: "remote",
            hash: this.hash === undefined ? undefined : this.hash && Buffer.from(this.hash).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], RemoteTransaction.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).hash)
], RemoteTransaction.prototype, "hash", void 0);
export class RemoveAccountAuthorityOperation {
    constructor(args) {
        this.type = AccountAuthOperationType.RemoveAuthority;
        this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    }
    copy() {
        return new RemoveAccountAuthorityOperation(this.asObject());
    }
    asObject() {
        return {
            type: "removeAuthority",
            authority: this.authority === undefined ? undefined : this.authority.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountAuthOperationType))
], RemoveAccountAuthorityOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], RemoveAccountAuthorityOperation.prototype, "authority", void 0);
export class RemoveKeyOperation {
    constructor(args) {
        this.type = KeyPageOperationType.Remove;
        this.entry =
            args.entry == undefined
                ? undefined
                : args.entry instanceof KeySpecParams
                    ? args.entry
                    : new KeySpecParams(args.entry);
    }
    copy() {
        return new RemoveKeyOperation(this.asObject());
    }
    asObject() {
        return {
            type: "remove",
            entry: this.entry === undefined ? undefined : this.entry.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(KeyPageOperationType))
], RemoveKeyOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).reference)
], RemoveKeyOperation.prototype, "entry", void 0);
export class Route {
    constructor(args) {
        this.length = args.length == undefined ? undefined : args.length;
        this.value = args.value == undefined ? undefined : args.value;
        this.partition = args.partition == undefined ? undefined : args.partition;
    }
    copy() {
        return new Route(this.asObject());
    }
    asObject() {
        return {
            length: this.length === undefined ? undefined : this.length,
            value: this.value === undefined ? undefined : this.value,
            partition: this.partition === undefined ? undefined : this.partition,
        };
    }
}
__decorate([
    (encodeAs.field(1).uint)
], Route.prototype, "length", void 0);
__decorate([
    (encodeAs.field(2).uint)
], Route.prototype, "value", void 0);
__decorate([
    (encodeAs.field(3).string)
], Route.prototype, "partition", void 0);
export class RouteOverride {
    constructor(args) {
        this.account = args.account == undefined ? undefined : URL.parse(args.account);
        this.partition = args.partition == undefined ? undefined : args.partition;
    }
    copy() {
        return new RouteOverride(this.asObject());
    }
    asObject() {
        return {
            account: this.account === undefined ? undefined : this.account.toString(),
            partition: this.partition === undefined ? undefined : this.partition,
        };
    }
}
__decorate([
    (encodeAs.field(1).url)
], RouteOverride.prototype, "account", void 0);
__decorate([
    (encodeAs.field(2).string)
], RouteOverride.prototype, "partition", void 0);
export class RoutingTable {
    constructor(args) {
        this.overrides =
            args.overrides == undefined
                ? undefined
                : args.overrides.map((v) => v == undefined ? undefined : v instanceof RouteOverride ? v : new RouteOverride(v));
        this.routes =
            args.routes == undefined
                ? undefined
                : args.routes.map((v) => v == undefined ? undefined : v instanceof Route ? v : new Route(v));
    }
    copy() {
        return new RoutingTable(this.asObject());
    }
    asObject() {
        return {
            overrides: this.overrides === undefined
                ? undefined
                : this.overrides?.map((v) => (v == undefined ? undefined : v.asObject())),
            routes: this.routes === undefined
                ? undefined
                : this.routes?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).repeatable.reference)
], RoutingTable.prototype, "overrides", void 0);
__decorate([
    (encodeAs.field(2).repeatable.reference)
], RoutingTable.prototype, "routes", void 0);
export class RsaSha256Signature {
    constructor(args) {
        this.type = SignatureType.RsaSha256;
        this.publicKey =
            args.publicKey == undefined
                ? undefined
                : args.publicKey instanceof Uint8Array
                    ? args.publicKey
                    : Buffer.from(args.publicKey, "hex");
        this.signature =
            args.signature == undefined
                ? undefined
                : args.signature instanceof Uint8Array
                    ? args.signature
                    : Buffer.from(args.signature, "hex");
        this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
        this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
        this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
        this.memo = args.memo == undefined ? undefined : args.memo;
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
    }
    copy() {
        return new RsaSha256Signature(this.asObject());
    }
    asObject() {
        return {
            type: "rsaSha256",
            publicKey: this.publicKey === undefined
                ? undefined
                : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
            signature: this.signature === undefined
                ? undefined
                : this.signature && Buffer.from(this.signature).toString("hex"),
            signer: this.signer === undefined ? undefined : this.signer.toString(),
            signerVersion: this.signerVersion === undefined ? undefined : this.signerVersion,
            timestamp: this.timestamp === undefined ? undefined : this.timestamp,
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
            memo: this.memo === undefined ? undefined : this.memo,
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], RsaSha256Signature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bytes)
], RsaSha256Signature.prototype, "publicKey", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], RsaSha256Signature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(4).url)
], RsaSha256Signature.prototype, "signer", void 0);
__decorate([
    (encodeAs.field(5).uint)
], RsaSha256Signature.prototype, "signerVersion", void 0);
__decorate([
    (encodeAs.field(6).uint)
], RsaSha256Signature.prototype, "timestamp", void 0);
__decorate([
    (encodeAs.field(7).enum)
], RsaSha256Signature.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(8).hash)
], RsaSha256Signature.prototype, "transactionHash", void 0);
__decorate([
    (encodeAs.field(9).string)
], RsaSha256Signature.prototype, "memo", void 0);
__decorate([
    (encodeAs.field(10).bytes)
], RsaSha256Signature.prototype, "data", void 0);
export class SendTokens {
    constructor(args) {
        this.type = TransactionType.SendTokens;
        this.hash =
            args.hash == undefined
                ? undefined
                : args.hash instanceof Uint8Array
                    ? args.hash
                    : Buffer.from(args.hash, "hex");
        this.meta = args.meta == undefined ? undefined : args.meta;
        this.to =
            args.to == undefined
                ? undefined
                : args.to.map((v) => v == undefined ? undefined : v instanceof TokenRecipient ? v : new TokenRecipient(v));
    }
    copy() {
        return new SendTokens(this.asObject());
    }
    asObject() {
        return {
            type: "sendTokens",
            hash: this.hash === undefined ? undefined : this.hash && Buffer.from(this.hash).toString("hex"),
            meta: this.meta === undefined ? undefined : this.meta,
            to: this.to === undefined
                ? undefined
                : this.to?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], SendTokens.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).hash)
], SendTokens.prototype, "hash", void 0);
__decorate([
    (encodeAs.field(3).rawJson)
], SendTokens.prototype, "meta", void 0);
__decorate([
    (encodeAs.field(4).repeatable.reference)
], SendTokens.prototype, "to", void 0);
export class SetRejectThresholdKeyPageOperation {
    constructor(args) {
        this.type = KeyPageOperationType.SetRejectThreshold;
        this.threshold = args.threshold == undefined ? undefined : args.threshold;
    }
    copy() {
        return new SetRejectThresholdKeyPageOperation(this.asObject());
    }
    asObject() {
        return {
            type: "setRejectThreshold",
            threshold: this.threshold === undefined ? undefined : this.threshold,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(KeyPageOperationType))
], SetRejectThresholdKeyPageOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).uint)
], SetRejectThresholdKeyPageOperation.prototype, "threshold", void 0);
export class SetResponseThresholdKeyPageOperation {
    constructor(args) {
        this.type = KeyPageOperationType.SetResponseThreshold;
        this.threshold = args.threshold == undefined ? undefined : args.threshold;
    }
    copy() {
        return new SetResponseThresholdKeyPageOperation(this.asObject());
    }
    asObject() {
        return {
            type: "setResponseThreshold",
            threshold: this.threshold === undefined ? undefined : this.threshold,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(KeyPageOperationType))
], SetResponseThresholdKeyPageOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).uint)
], SetResponseThresholdKeyPageOperation.prototype, "threshold", void 0);
export class SetThresholdKeyPageOperation {
    constructor(args) {
        this.type = KeyPageOperationType.SetThreshold;
        this.threshold = args.threshold == undefined ? undefined : args.threshold;
    }
    copy() {
        return new SetThresholdKeyPageOperation(this.asObject());
    }
    asObject() {
        return {
            type: "setThreshold",
            threshold: this.threshold === undefined ? undefined : this.threshold,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(KeyPageOperationType))
], SetThresholdKeyPageOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).uint)
], SetThresholdKeyPageOperation.prototype, "threshold", void 0);
export class SignatureSet {
    constructor(args) {
        this.type = SignatureType.Set;
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
        this.signatures =
            args.signatures == undefined
                ? undefined
                : args.signatures.map((v) => (v == undefined ? undefined : Signature.fromObject(v)));
        this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    }
    copy() {
        return new SignatureSet(this.asObject());
    }
    asObject() {
        return {
            type: "set",
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            signer: this.signer === undefined ? undefined : this.signer.toString(),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
            signatures: this.signatures === undefined
                ? undefined
                : this.signatures?.map((v) => (v == undefined ? undefined : v.asObject())),
            authority: this.authority === undefined ? undefined : this.authority.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], SignatureSet.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).enum)
], SignatureSet.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(3).url)
], SignatureSet.prototype, "signer", void 0);
__decorate([
    (encodeAs.field(4).hash)
], SignatureSet.prototype, "transactionHash", void 0);
__decorate([
    (encodeAs.field(5).repeatable.union)
], SignatureSet.prototype, "signatures", void 0);
__decorate([
    (encodeAs.field(6).url)
], SignatureSet.prototype, "authority", void 0);
export class SyntheticBurnTokens {
    constructor(args) {
        this.type = TransactionType.SyntheticBurnTokens;
        this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
        this.source = args.source == undefined ? undefined : URL.parse(args.source);
        this.initiator = args.initiator == undefined ? undefined : URL.parse(args.initiator);
        this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
        this.index = args.index == undefined ? undefined : args.index;
        this.amount =
            args.amount == undefined
                ? undefined
                : typeof args.amount === "bigint"
                    ? args.amount
                    : BigInt(args.amount);
        this.isRefund = args.isRefund == undefined ? undefined : args.isRefund;
    }
    copy() {
        return new SyntheticBurnTokens(this.asObject());
    }
    asObject() {
        return {
            type: "syntheticBurnTokens",
            cause: this.cause === undefined ? undefined : this.cause.toString(),
            source: this.source === undefined ? undefined : this.source.toString(),
            initiator: this.initiator === undefined ? undefined : this.initiator.toString(),
            feeRefund: this.feeRefund === undefined ? undefined : this.feeRefund,
            index: this.index === undefined ? undefined : this.index,
            amount: this.amount === undefined ? undefined : this.amount.toString(),
            isRefund: this.isRefund === undefined ? undefined : this.isRefund,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], SyntheticBurnTokens.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2, 1).txid)
], SyntheticBurnTokens.prototype, "cause", void 0);
__decorate([
    (encodeAs.field(2, 0).url)
], SyntheticBurnTokens.prototype, "source", void 0);
__decorate([
    (encodeAs.field(2, 3).url)
], SyntheticBurnTokens.prototype, "initiator", void 0);
__decorate([
    (encodeAs.field(2, 4).uint)
], SyntheticBurnTokens.prototype, "feeRefund", void 0);
__decorate([
    (encodeAs.field(2, 5).uint)
], SyntheticBurnTokens.prototype, "index", void 0);
__decorate([
    (encodeAs.field(3).bigInt)
], SyntheticBurnTokens.prototype, "amount", void 0);
__decorate([
    (encodeAs.field(4).bool)
], SyntheticBurnTokens.prototype, "isRefund", void 0);
export class SyntheticCreateIdentity {
    constructor(args) {
        this.type = TransactionType.SyntheticCreateIdentity;
        this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
        this.source = args.source == undefined ? undefined : URL.parse(args.source);
        this.initiator = args.initiator == undefined ? undefined : URL.parse(args.initiator);
        this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
        this.index = args.index == undefined ? undefined : args.index;
        this.accounts =
            args.accounts == undefined
                ? undefined
                : args.accounts.map((v) => (v == undefined ? undefined : Account.fromObject(v)));
    }
    copy() {
        return new SyntheticCreateIdentity(this.asObject());
    }
    asObject() {
        return {
            type: "syntheticCreateIdentity",
            cause: this.cause === undefined ? undefined : this.cause.toString(),
            source: this.source === undefined ? undefined : this.source.toString(),
            initiator: this.initiator === undefined ? undefined : this.initiator.toString(),
            feeRefund: this.feeRefund === undefined ? undefined : this.feeRefund,
            index: this.index === undefined ? undefined : this.index,
            accounts: this.accounts === undefined
                ? undefined
                : this.accounts?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], SyntheticCreateIdentity.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2, 1).txid)
], SyntheticCreateIdentity.prototype, "cause", void 0);
__decorate([
    (encodeAs.field(2, 0).url)
], SyntheticCreateIdentity.prototype, "source", void 0);
__decorate([
    (encodeAs.field(2, 3).url)
], SyntheticCreateIdentity.prototype, "initiator", void 0);
__decorate([
    (encodeAs.field(2, 4).uint)
], SyntheticCreateIdentity.prototype, "feeRefund", void 0);
__decorate([
    (encodeAs.field(2, 5).uint)
], SyntheticCreateIdentity.prototype, "index", void 0);
__decorate([
    (encodeAs.field(3).repeatable.union)
], SyntheticCreateIdentity.prototype, "accounts", void 0);
export class SyntheticDepositCredits {
    constructor(args) {
        this.type = TransactionType.SyntheticDepositCredits;
        this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
        this.source = args.source == undefined ? undefined : URL.parse(args.source);
        this.initiator = args.initiator == undefined ? undefined : URL.parse(args.initiator);
        this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
        this.index = args.index == undefined ? undefined : args.index;
        this.amount = args.amount == undefined ? undefined : args.amount;
        this.acmeRefundAmount =
            args.acmeRefundAmount == undefined
                ? undefined
                : typeof args.acmeRefundAmount === "bigint"
                    ? args.acmeRefundAmount
                    : BigInt(args.acmeRefundAmount);
        this.isRefund = args.isRefund == undefined ? undefined : args.isRefund;
    }
    copy() {
        return new SyntheticDepositCredits(this.asObject());
    }
    asObject() {
        return {
            type: "syntheticDepositCredits",
            cause: this.cause === undefined ? undefined : this.cause.toString(),
            source: this.source === undefined ? undefined : this.source.toString(),
            initiator: this.initiator === undefined ? undefined : this.initiator.toString(),
            feeRefund: this.feeRefund === undefined ? undefined : this.feeRefund,
            index: this.index === undefined ? undefined : this.index,
            amount: this.amount === undefined ? undefined : this.amount,
            acmeRefundAmount: this.acmeRefundAmount === undefined ? undefined : this.acmeRefundAmount.toString(),
            isRefund: this.isRefund === undefined ? undefined : this.isRefund,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], SyntheticDepositCredits.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2, 1).txid)
], SyntheticDepositCredits.prototype, "cause", void 0);
__decorate([
    (encodeAs.field(2, 0).url)
], SyntheticDepositCredits.prototype, "source", void 0);
__decorate([
    (encodeAs.field(2, 3).url)
], SyntheticDepositCredits.prototype, "initiator", void 0);
__decorate([
    (encodeAs.field(2, 4).uint)
], SyntheticDepositCredits.prototype, "feeRefund", void 0);
__decorate([
    (encodeAs.field(2, 5).uint)
], SyntheticDepositCredits.prototype, "index", void 0);
__decorate([
    (encodeAs.field(3).uint)
], SyntheticDepositCredits.prototype, "amount", void 0);
__decorate([
    (encodeAs.field(4).bigInt)
], SyntheticDepositCredits.prototype, "acmeRefundAmount", void 0);
__decorate([
    (encodeAs.field(5).bool)
], SyntheticDepositCredits.prototype, "isRefund", void 0);
export class SyntheticDepositTokens {
    constructor(args) {
        this.type = TransactionType.SyntheticDepositTokens;
        this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
        this.source = args.source == undefined ? undefined : URL.parse(args.source);
        this.initiator = args.initiator == undefined ? undefined : URL.parse(args.initiator);
        this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
        this.index = args.index == undefined ? undefined : args.index;
        this.token = args.token == undefined ? undefined : URL.parse(args.token);
        this.amount =
            args.amount == undefined
                ? undefined
                : typeof args.amount === "bigint"
                    ? args.amount
                    : BigInt(args.amount);
        this.isIssuer = args.isIssuer == undefined ? undefined : args.isIssuer;
        this.isRefund = args.isRefund == undefined ? undefined : args.isRefund;
    }
    copy() {
        return new SyntheticDepositTokens(this.asObject());
    }
    asObject() {
        return {
            type: "syntheticDepositTokens",
            cause: this.cause === undefined ? undefined : this.cause.toString(),
            source: this.source === undefined ? undefined : this.source.toString(),
            initiator: this.initiator === undefined ? undefined : this.initiator.toString(),
            feeRefund: this.feeRefund === undefined ? undefined : this.feeRefund,
            index: this.index === undefined ? undefined : this.index,
            token: this.token === undefined ? undefined : this.token.toString(),
            amount: this.amount === undefined ? undefined : this.amount.toString(),
            isIssuer: this.isIssuer === undefined ? undefined : this.isIssuer,
            isRefund: this.isRefund === undefined ? undefined : this.isRefund,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], SyntheticDepositTokens.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2, 1).txid)
], SyntheticDepositTokens.prototype, "cause", void 0);
__decorate([
    (encodeAs.field(2, 0).url)
], SyntheticDepositTokens.prototype, "source", void 0);
__decorate([
    (encodeAs.field(2, 3).url)
], SyntheticDepositTokens.prototype, "initiator", void 0);
__decorate([
    (encodeAs.field(2, 4).uint)
], SyntheticDepositTokens.prototype, "feeRefund", void 0);
__decorate([
    (encodeAs.field(2, 5).uint)
], SyntheticDepositTokens.prototype, "index", void 0);
__decorate([
    (encodeAs.field(3).url)
], SyntheticDepositTokens.prototype, "token", void 0);
__decorate([
    (encodeAs.field(4).bigInt)
], SyntheticDepositTokens.prototype, "amount", void 0);
__decorate([
    (encodeAs.field(5).bool)
], SyntheticDepositTokens.prototype, "isIssuer", void 0);
__decorate([
    (encodeAs.field(6).bool)
], SyntheticDepositTokens.prototype, "isRefund", void 0);
export class SyntheticForwardTransaction {
    constructor(args) {
        this.type = TransactionType.SyntheticForwardTransaction;
        this.signatures =
            args.signatures == undefined
                ? undefined
                : args.signatures.map((v) => v == undefined ? undefined : v instanceof RemoteSignature ? v : new RemoteSignature(v));
        this.transaction =
            args.transaction == undefined
                ? undefined
                : args.transaction instanceof Transaction
                    ? args.transaction
                    : new Transaction(args.transaction);
    }
    copy() {
        return new SyntheticForwardTransaction(this.asObject());
    }
    asObject() {
        return {
            type: "syntheticForwardTransaction",
            signatures: this.signatures === undefined
                ? undefined
                : this.signatures?.map((v) => (v == undefined ? undefined : v.asObject())),
            transaction: this.transaction === undefined ? undefined : this.transaction.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], SyntheticForwardTransaction.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).repeatable.reference)
], SyntheticForwardTransaction.prototype, "signatures", void 0);
__decorate([
    (encodeAs.field(3).reference)
], SyntheticForwardTransaction.prototype, "transaction", void 0);
export class SyntheticLedger {
    constructor(args) {
        this.type = AccountType.SyntheticLedger;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.sequence =
            args.sequence == undefined
                ? undefined
                : args.sequence.map((v) => v == undefined
                    ? undefined
                    : v instanceof PartitionSyntheticLedger
                        ? v
                        : new PartitionSyntheticLedger(v));
    }
    copy() {
        return new SyntheticLedger(this.asObject());
    }
    asObject() {
        return {
            type: "syntheticLedger",
            url: this.url === undefined ? undefined : this.url.toString(),
            sequence: this.sequence === undefined
                ? undefined
                : this.sequence?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], SyntheticLedger.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], SyntheticLedger.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).repeatable.reference)
], SyntheticLedger.prototype, "sequence", void 0);
export class SyntheticOrigin {
    constructor(args) {
        this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
        this.initiator = args.initiator == undefined ? undefined : URL.parse(args.initiator);
        this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
        this.index = args.index == undefined ? undefined : args.index;
    }
    copy() {
        return new SyntheticOrigin(this.asObject());
    }
    asObject() {
        return {
            cause: this.cause === undefined ? undefined : this.cause.toString(),
            initiator: this.initiator === undefined ? undefined : this.initiator.toString(),
            feeRefund: this.feeRefund === undefined ? undefined : this.feeRefund,
            index: this.index === undefined ? undefined : this.index,
        };
    }
}
__decorate([
    (encodeAs.field(1).txid)
], SyntheticOrigin.prototype, "cause", void 0);
__decorate([
    (encodeAs.field(3).url)
], SyntheticOrigin.prototype, "initiator", void 0);
__decorate([
    (encodeAs.field(4).uint)
], SyntheticOrigin.prototype, "feeRefund", void 0);
__decorate([
    (encodeAs.field(5).uint)
], SyntheticOrigin.prototype, "index", void 0);
export class SyntheticWriteData {
    constructor(args) {
        this.type = TransactionType.SyntheticWriteData;
        this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
        this.source = args.source == undefined ? undefined : URL.parse(args.source);
        this.initiator = args.initiator == undefined ? undefined : URL.parse(args.initiator);
        this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
        this.index = args.index == undefined ? undefined : args.index;
        this.entry = args.entry == undefined ? undefined : DataEntry.fromObject(args.entry);
    }
    copy() {
        return new SyntheticWriteData(this.asObject());
    }
    asObject() {
        return {
            type: "syntheticWriteData",
            cause: this.cause === undefined ? undefined : this.cause.toString(),
            source: this.source === undefined ? undefined : this.source.toString(),
            initiator: this.initiator === undefined ? undefined : this.initiator.toString(),
            feeRefund: this.feeRefund === undefined ? undefined : this.feeRefund,
            index: this.index === undefined ? undefined : this.index,
            entry: this.entry === undefined ? undefined : this.entry.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], SyntheticWriteData.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2, 1).txid)
], SyntheticWriteData.prototype, "cause", void 0);
__decorate([
    (encodeAs.field(2, 0).url)
], SyntheticWriteData.prototype, "source", void 0);
__decorate([
    (encodeAs.field(2, 3).url)
], SyntheticWriteData.prototype, "initiator", void 0);
__decorate([
    (encodeAs.field(2, 4).uint)
], SyntheticWriteData.prototype, "feeRefund", void 0);
__decorate([
    (encodeAs.field(2, 5).uint)
], SyntheticWriteData.prototype, "index", void 0);
__decorate([
    (encodeAs.field(3).union)
], SyntheticWriteData.prototype, "entry", void 0);
export class SystemGenesis {
    constructor(_) {
        this.type = TransactionType.SystemGenesis;
    }
    copy() {
        return new SystemGenesis(this.asObject());
    }
    asObject() {
        return {
            type: "systemGenesis",
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], SystemGenesis.prototype, "type", void 0);
export class SystemLedger {
    constructor(args) {
        this.type = AccountType.SystemLedger;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.index = args.index == undefined ? undefined : args.index;
        this.timestamp =
            args.timestamp == undefined
                ? undefined
                : args.timestamp instanceof Date
                    ? args.timestamp
                    : new Date(args.timestamp);
        this.acmeBurnt =
            args.acmeBurnt == undefined
                ? undefined
                : typeof args.acmeBurnt === "bigint"
                    ? args.acmeBurnt
                    : BigInt(args.acmeBurnt);
        this.pendingUpdates =
            args.pendingUpdates == undefined
                ? undefined
                : args.pendingUpdates.map((v) => v == undefined
                    ? undefined
                    : v instanceof NetworkAccountUpdate
                        ? v
                        : new NetworkAccountUpdate(v));
        this.anchor = args.anchor == undefined ? undefined : getAnchorBodyClass().fromObject(args.anchor);
        this.executorVersion =
            args.executorVersion == undefined
                ? undefined
                : ExecutorVersion.fromObject(args.executorVersion);
        this.bvnExecutorVersions =
            args.bvnExecutorVersions == undefined
                ? undefined
                : args.bvnExecutorVersions.map((v) => v == undefined
                    ? undefined
                    : v instanceof PartitionExecutorVersion
                        ? v
                        : new PartitionExecutorVersion(v));
    }
    copy() {
        return new SystemLedger(this.asObject());
    }
    asObject() {
        return {
            type: "systemLedger",
            url: this.url === undefined ? undefined : this.url.toString(),
            index: this.index === undefined ? undefined : this.index,
            timestamp: this.timestamp === undefined ? undefined : this.timestamp,
            acmeBurnt: this.acmeBurnt === undefined ? undefined : this.acmeBurnt.toString(),
            pendingUpdates: this.pendingUpdates === undefined
                ? undefined
                : this.pendingUpdates?.map((v) => (v == undefined ? undefined : v.asObject())),
            anchor: this.anchor === undefined ? undefined : this.anchor.asObject(),
            executorVersion: this.executorVersion === undefined
                ? undefined
                : ExecutorVersion.getName(this.executorVersion),
            bvnExecutorVersions: this.bvnExecutorVersions === undefined
                ? undefined
                : this.bvnExecutorVersions?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], SystemLedger.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], SystemLedger.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).uint)
], SystemLedger.prototype, "index", void 0);
__decorate([
    (encodeAs.field(4).time)
], SystemLedger.prototype, "timestamp", void 0);
__decorate([
    (encodeAs.field(5).bigInt)
], SystemLedger.prototype, "acmeBurnt", void 0);
__decorate([
    (encodeAs.field(6).repeatable.reference)
], SystemLedger.prototype, "pendingUpdates", void 0);
__decorate([
    (encodeAs.field(7).union)
], SystemLedger.prototype, "anchor", void 0);
__decorate([
    (encodeAs.field(8).enum)
], SystemLedger.prototype, "executorVersion", void 0);
__decorate([
    (encodeAs.field(9).repeatable.reference)
], SystemLedger.prototype, "bvnExecutorVersions", void 0);
export class SystemWriteData {
    constructor(args) {
        this.type = TransactionType.SystemWriteData;
        this.entry = args.entry == undefined ? undefined : DataEntry.fromObject(args.entry);
        this.writeToState = args.writeToState == undefined ? undefined : args.writeToState;
    }
    copy() {
        return new SystemWriteData(this.asObject());
    }
    asObject() {
        return {
            type: "systemWriteData",
            entry: this.entry === undefined ? undefined : this.entry.asObject(),
            writeToState: this.writeToState === undefined ? undefined : this.writeToState,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], SystemWriteData.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).union)
], SystemWriteData.prototype, "entry", void 0);
__decorate([
    (encodeAs.field(3).bool)
], SystemWriteData.prototype, "writeToState", void 0);
export class TokenAccount {
    constructor(args) {
        this.type = AccountType.TokenAccount;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => v == undefined ? undefined : v instanceof AuthorityEntry ? v : new AuthorityEntry(v));
        this.tokenUrl = args.tokenUrl == undefined ? undefined : URL.parse(args.tokenUrl);
        this.balance =
            args.balance == undefined
                ? undefined
                : typeof args.balance === "bigint"
                    ? args.balance
                    : BigInt(args.balance);
    }
    copy() {
        return new TokenAccount(this.asObject());
    }
    asObject() {
        return {
            type: "tokenAccount",
            url: this.url === undefined ? undefined : this.url.toString(),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.asObject())),
            tokenUrl: this.tokenUrl === undefined ? undefined : this.tokenUrl.toString(),
            balance: this.balance === undefined ? undefined : this.balance.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], TokenAccount.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], TokenAccount.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3, 1).repeatable.reference)
], TokenAccount.prototype, "authorities", void 0);
__decorate([
    (encodeAs.field(4).url)
], TokenAccount.prototype, "tokenUrl", void 0);
__decorate([
    (encodeAs.field(5).bigInt)
], TokenAccount.prototype, "balance", void 0);
export class TokenIssuer {
    constructor(args) {
        this.type = AccountType.TokenIssuer;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => v == undefined ? undefined : v instanceof AuthorityEntry ? v : new AuthorityEntry(v));
        this.symbol = args.symbol == undefined ? undefined : args.symbol;
        this.precision = args.precision == undefined ? undefined : args.precision;
        this.properties = args.properties == undefined ? undefined : URL.parse(args.properties);
        this.issued =
            args.issued == undefined
                ? undefined
                : typeof args.issued === "bigint"
                    ? args.issued
                    : BigInt(args.issued);
        this.supplyLimit =
            args.supplyLimit == undefined
                ? undefined
                : typeof args.supplyLimit === "bigint"
                    ? args.supplyLimit
                    : BigInt(args.supplyLimit);
    }
    copy() {
        return new TokenIssuer(this.asObject());
    }
    asObject() {
        return {
            type: "tokenIssuer",
            url: this.url === undefined ? undefined : this.url.toString(),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.asObject())),
            symbol: this.symbol === undefined ? undefined : this.symbol,
            precision: this.precision === undefined ? undefined : this.precision,
            properties: this.properties === undefined ? undefined : this.properties.toString(),
            issued: this.issued === undefined ? undefined : this.issued.toString(),
            supplyLimit: this.supplyLimit === undefined ? undefined : this.supplyLimit.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], TokenIssuer.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], TokenIssuer.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3, 1).repeatable.reference)
], TokenIssuer.prototype, "authorities", void 0);
__decorate([
    (encodeAs.field(4).string)
], TokenIssuer.prototype, "symbol", void 0);
__decorate([
    (encodeAs.field(5).uint)
], TokenIssuer.prototype, "precision", void 0);
__decorate([
    (encodeAs.field(6).url)
], TokenIssuer.prototype, "properties", void 0);
__decorate([
    (encodeAs.field(7).bigInt)
], TokenIssuer.prototype, "issued", void 0);
__decorate([
    (encodeAs.field(8).bigInt)
], TokenIssuer.prototype, "supplyLimit", void 0);
export class TokenIssuerProof {
    constructor(args) {
        this.transaction =
            args.transaction == undefined
                ? undefined
                : args.transaction instanceof CreateToken
                    ? args.transaction
                    : new CreateToken(args.transaction);
        this.receipt =
            args.receipt == undefined
                ? undefined
                : args.receipt instanceof merkle.Receipt
                    ? args.receipt
                    : new merkle.Receipt(args.receipt);
    }
    copy() {
        return new TokenIssuerProof(this.asObject());
    }
    asObject() {
        return {
            transaction: this.transaction === undefined ? undefined : this.transaction.asObject(),
            receipt: this.receipt === undefined ? undefined : this.receipt.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).reference)
], TokenIssuerProof.prototype, "transaction", void 0);
__decorate([
    (encodeAs.field(2).reference)
], TokenIssuerProof.prototype, "receipt", void 0);
export class TokenRecipient {
    constructor(args) {
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.amount =
            args.amount == undefined
                ? undefined
                : typeof args.amount === "bigint"
                    ? args.amount
                    : BigInt(args.amount);
    }
    copy() {
        return new TokenRecipient(this.asObject());
    }
    asObject() {
        return {
            url: this.url === undefined ? undefined : this.url.toString(),
            amount: this.amount === undefined ? undefined : this.amount.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).url)
], TokenRecipient.prototype, "url", void 0);
__decorate([
    (encodeAs.field(2).bigInt)
], TokenRecipient.prototype, "amount", void 0);
export class Transaction extends TransactionBase {
    constructor(args) {
        super();
        this.header =
            args.header == undefined
                ? undefined
                : args.header instanceof TransactionHeader
                    ? args.header
                    : new TransactionHeader(args.header);
        this.body = args.body == undefined ? undefined : TransactionBody.fromObject(args.body);
    }
    copy() {
        return new Transaction(this.asObject());
    }
    asObject() {
        return {
            header: this.header === undefined ? undefined : this.header.asObject(),
            body: this.body === undefined ? undefined : this.body.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).reference)
], Transaction.prototype, "header", void 0);
__decorate([
    (encodeAs.field(2).union)
], Transaction.prototype, "body", void 0);
export class TransactionHeader {
    constructor(args) {
        this.principal = args.principal == undefined ? undefined : URL.parse(args.principal);
        this.initiator =
            args.initiator == undefined
                ? undefined
                : args.initiator instanceof Uint8Array
                    ? args.initiator
                    : Buffer.from(args.initiator, "hex");
        this.memo = args.memo == undefined ? undefined : args.memo;
        this.metadata =
            args.metadata == undefined
                ? undefined
                : args.metadata instanceof Uint8Array
                    ? args.metadata
                    : Buffer.from(args.metadata, "hex");
        this.expire =
            args.expire == undefined
                ? undefined
                : args.expire instanceof ExpireOptions
                    ? args.expire
                    : new ExpireOptions(args.expire);
        this.holdUntil =
            args.holdUntil == undefined
                ? undefined
                : args.holdUntil instanceof HoldUntilOptions
                    ? args.holdUntil
                    : new HoldUntilOptions(args.holdUntil);
        this.authorities =
            args.authorities == undefined
                ? undefined
                : args.authorities.map((v) => (v == undefined ? undefined : URL.parse(v)));
    }
    copy() {
        return new TransactionHeader(this.asObject());
    }
    asObject() {
        return {
            principal: this.principal === undefined ? undefined : this.principal.toString(),
            initiator: this.initiator === undefined
                ? undefined
                : this.initiator && Buffer.from(this.initiator).toString("hex"),
            memo: this.memo === undefined ? undefined : this.memo,
            metadata: this.metadata === undefined
                ? undefined
                : this.metadata && Buffer.from(this.metadata).toString("hex"),
            expire: this.expire === undefined ? undefined : this.expire.asObject(),
            holdUntil: this.holdUntil === undefined ? undefined : this.holdUntil.asObject(),
            authorities: this.authorities === undefined
                ? undefined
                : this.authorities?.map((v) => (v == undefined ? undefined : v.toString())),
        };
    }
}
__decorate([
    (encodeAs.field(1).url)
], TransactionHeader.prototype, "principal", void 0);
__decorate([
    (encodeAs.field(2).hash)
], TransactionHeader.prototype, "initiator", void 0);
__decorate([
    (encodeAs.field(3).string)
], TransactionHeader.prototype, "memo", void 0);
__decorate([
    (encodeAs.field(4).bytes)
], TransactionHeader.prototype, "metadata", void 0);
__decorate([
    (encodeAs.field(5).reference)
], TransactionHeader.prototype, "expire", void 0);
__decorate([
    (encodeAs.field(6).reference)
], TransactionHeader.prototype, "holdUntil", void 0);
__decorate([
    (encodeAs.field(7).repeatable.url)
], TransactionHeader.prototype, "authorities", void 0);
export class TransactionStatus {
    constructor(args) {
        this.txID = args.txID == undefined ? undefined : TxID.parse(args.txID);
        this.code = args.code == undefined ? undefined : errors2.Status.fromObject(args.code);
        this.error =
            args.error == undefined
                ? undefined
                : args.error instanceof errors2.Error
                    ? args.error
                    : new errors2.Error(args.error);
        this.result = args.result == undefined ? undefined : getTransactionResultClass().fromObject(args.result);
        this.received = args.received == undefined ? undefined : args.received;
        this.initiator = args.initiator == undefined ? undefined : URL.parse(args.initiator);
        this.signers =
            args.signers == undefined
                ? undefined
                : args.signers.map((v) => (v == undefined ? undefined : getSignerClass().fromObject(v)));
        this.sourceNetwork =
            args.sourceNetwork == undefined ? undefined : URL.parse(args.sourceNetwork);
        this.destinationNetwork =
            args.destinationNetwork == undefined ? undefined : URL.parse(args.destinationNetwork);
        this.sequenceNumber = args.sequenceNumber == undefined ? undefined : args.sequenceNumber;
        this.gotDirectoryReceipt =
            args.gotDirectoryReceipt == undefined ? undefined : args.gotDirectoryReceipt;
        this.proof =
            args.proof == undefined
                ? undefined
                : args.proof instanceof merkle.Receipt
                    ? args.proof
                    : new merkle.Receipt(args.proof);
        this.anchorSigners =
            args.anchorSigners == undefined
                ? undefined
                : args.anchorSigners.map((v) => v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"));
    }
    copy() {
        return new TransactionStatus(this.asObject());
    }
    asObject() {
        return {
            txID: this.txID === undefined ? undefined : this.txID.toString(),
            code: this.code === undefined ? undefined : errors2.Status.getName(this.code),
            error: this.error === undefined ? undefined : this.error.asObject(),
            result: this.result === undefined ? undefined : this.result.asObject(),
            received: this.received === undefined ? undefined : this.received,
            initiator: this.initiator === undefined ? undefined : this.initiator.toString(),
            signers: this.signers === undefined
                ? undefined
                : this.signers?.map((v) => (v == undefined ? undefined : v.asObject())),
            sourceNetwork: this.sourceNetwork === undefined ? undefined : this.sourceNetwork.toString(),
            destinationNetwork: this.destinationNetwork === undefined ? undefined : this.destinationNetwork.toString(),
            sequenceNumber: this.sequenceNumber === undefined ? undefined : this.sequenceNumber,
            gotDirectoryReceipt: this.gotDirectoryReceipt === undefined ? undefined : this.gotDirectoryReceipt,
            proof: this.proof === undefined ? undefined : this.proof.asObject(),
            anchorSigners: this.anchorSigners === undefined
                ? undefined
                : this.anchorSigners?.map((v) => v == undefined ? undefined : v && Buffer.from(v).toString("hex")),
        };
    }
}
__decorate([
    (encodeAs.field(1).txid)
], TransactionStatus.prototype, "txID", void 0);
__decorate([
    (encodeAs.field(2).enum)
], TransactionStatus.prototype, "code", void 0);
__decorate([
    (encodeAs.field(3).reference)
], TransactionStatus.prototype, "error", void 0);
__decorate([
    (encodeAs.field(4).union)
], TransactionStatus.prototype, "result", void 0);
__decorate([
    (encodeAs.field(5).uint)
], TransactionStatus.prototype, "received", void 0);
__decorate([
    (encodeAs.field(6).url)
], TransactionStatus.prototype, "initiator", void 0);
__decorate([
    (encodeAs.field(7).repeatable.union)
], TransactionStatus.prototype, "signers", void 0);
__decorate([
    (encodeAs.field(8).url)
], TransactionStatus.prototype, "sourceNetwork", void 0);
__decorate([
    (encodeAs.field(9).url)
], TransactionStatus.prototype, "destinationNetwork", void 0);
__decorate([
    (encodeAs.field(10).uint)
], TransactionStatus.prototype, "sequenceNumber", void 0);
__decorate([
    (encodeAs.field(11).bool)
], TransactionStatus.prototype, "gotDirectoryReceipt", void 0);
__decorate([
    (encodeAs.field(12).reference)
], TransactionStatus.prototype, "proof", void 0);
__decorate([
    (encodeAs.field(13).repeatable.bytes)
], TransactionStatus.prototype, "anchorSigners", void 0);
export class TransferCredits {
    constructor(args) {
        this.type = TransactionType.TransferCredits;
        this.to =
            args.to == undefined
                ? undefined
                : args.to.map((v) => v == undefined ? undefined : v instanceof CreditRecipient ? v : new CreditRecipient(v));
    }
    copy() {
        return new TransferCredits(this.asObject());
    }
    asObject() {
        return {
            type: "transferCredits",
            to: this.to === undefined
                ? undefined
                : this.to?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], TransferCredits.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).repeatable.reference)
], TransferCredits.prototype, "to", void 0);
export class TxIdSet {
    constructor(args) {
        this.entries =
            args.entries == undefined
                ? undefined
                : args.entries.map((v) => (v == undefined ? undefined : TxID.parse(v)));
    }
    copy() {
        return new TxIdSet(this.asObject());
    }
    asObject() {
        return {
            entries: this.entries === undefined
                ? undefined
                : this.entries?.map((v) => (v == undefined ? undefined : v.toString())),
        };
    }
}
__decorate([
    (encodeAs.field(1).repeatable.txid)
], TxIdSet.prototype, "entries", void 0);
export class TypedDataSignature {
    constructor(args) {
        this.type = SignatureType.TypedData;
        this.publicKey =
            args.publicKey == undefined
                ? undefined
                : args.publicKey instanceof Uint8Array
                    ? args.publicKey
                    : Buffer.from(args.publicKey, "hex");
        this.signature =
            args.signature == undefined
                ? undefined
                : args.signature instanceof Uint8Array
                    ? args.signature
                    : Buffer.from(args.signature, "hex");
        this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
        this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
        this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
        this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
        this.transactionHash =
            args.transactionHash == undefined
                ? undefined
                : args.transactionHash instanceof Uint8Array
                    ? args.transactionHash
                    : Buffer.from(args.transactionHash, "hex");
        this.memo = args.memo == undefined ? undefined : args.memo;
        this.data =
            args.data == undefined
                ? undefined
                : args.data instanceof Uint8Array
                    ? args.data
                    : Buffer.from(args.data, "hex");
        this.chainID =
            args.chainID == undefined
                ? undefined
                : typeof args.chainID === "bigint"
                    ? args.chainID
                    : BigInt(args.chainID);
    }
    copy() {
        return new TypedDataSignature(this.asObject());
    }
    asObject() {
        return {
            type: "typedData",
            publicKey: this.publicKey === undefined
                ? undefined
                : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
            signature: this.signature === undefined
                ? undefined
                : this.signature && Buffer.from(this.signature).toString("hex"),
            signer: this.signer === undefined ? undefined : this.signer.toString(),
            signerVersion: this.signerVersion === undefined ? undefined : this.signerVersion,
            timestamp: this.timestamp === undefined ? undefined : this.timestamp,
            vote: this.vote === undefined ? undefined : VoteType.getName(this.vote),
            transactionHash: this.transactionHash === undefined
                ? undefined
                : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
            memo: this.memo === undefined ? undefined : this.memo,
            data: this.data === undefined ? undefined : this.data && Buffer.from(this.data).toString("hex"),
            chainID: this.chainID === undefined ? undefined : this.chainID.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(SignatureType))
], TypedDataSignature.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bytes)
], TypedDataSignature.prototype, "publicKey", void 0);
__decorate([
    (encodeAs.field(3).bytes)
], TypedDataSignature.prototype, "signature", void 0);
__decorate([
    (encodeAs.field(4).url)
], TypedDataSignature.prototype, "signer", void 0);
__decorate([
    (encodeAs.field(5).uint)
], TypedDataSignature.prototype, "signerVersion", void 0);
__decorate([
    (encodeAs.field(6).uint)
], TypedDataSignature.prototype, "timestamp", void 0);
__decorate([
    (encodeAs.field(7).enum)
], TypedDataSignature.prototype, "vote", void 0);
__decorate([
    (encodeAs.field(8).hash)
], TypedDataSignature.prototype, "transactionHash", void 0);
__decorate([
    (encodeAs.field(9).string)
], TypedDataSignature.prototype, "memo", void 0);
__decorate([
    (encodeAs.field(10).bytes)
], TypedDataSignature.prototype, "data", void 0);
__decorate([
    (encodeAs.field(11).bigInt)
], TypedDataSignature.prototype, "chainID", void 0);
export class UnknownAccount {
    constructor(args) {
        this.type = AccountType.Unknown;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
    }
    copy() {
        return new UnknownAccount(this.asObject());
    }
    asObject() {
        return {
            type: "unknown",
            url: this.url === undefined ? undefined : this.url.toString(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], UnknownAccount.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], UnknownAccount.prototype, "url", void 0);
export class UnknownSigner {
    constructor(args) {
        this.type = AccountType.UnknownSigner;
        this.url = args.url == undefined ? undefined : URL.parse(args.url);
        this.version = args.version == undefined ? undefined : args.version;
    }
    copy() {
        return new UnknownSigner(this.asObject());
    }
    asObject() {
        return {
            type: "unknownSigner",
            url: this.url === undefined ? undefined : this.url.toString(),
            version: this.version === undefined ? undefined : this.version,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(AccountType))
], UnknownSigner.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], UnknownSigner.prototype, "url", void 0);
__decorate([
    (encodeAs.field(3).uint)
], UnknownSigner.prototype, "version", void 0);
export class UpdateAccountAuth {
    constructor(args) {
        this.type = TransactionType.UpdateAccountAuth;
        this.operations =
            args.operations == undefined
                ? undefined
                : args.operations.map((v) => v == undefined ? undefined : AccountAuthOperation.fromObject(v));
    }
    copy() {
        return new UpdateAccountAuth(this.asObject());
    }
    asObject() {
        return {
            type: "updateAccountAuth",
            operations: this.operations === undefined
                ? undefined
                : this.operations?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], UpdateAccountAuth.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).repeatable.union)
], UpdateAccountAuth.prototype, "operations", void 0);
export class UpdateAllowedKeyPageOperation {
    constructor(args) {
        this.type = KeyPageOperationType.UpdateAllowed;
        this.allow =
            args.allow == undefined
                ? undefined
                : args.allow.map((v) => (v == undefined ? undefined : TransactionType.fromObject(v)));
        this.deny =
            args.deny == undefined
                ? undefined
                : args.deny.map((v) => (v == undefined ? undefined : TransactionType.fromObject(v)));
    }
    copy() {
        return new UpdateAllowedKeyPageOperation(this.asObject());
    }
    asObject() {
        return {
            type: "updateAllowed",
            allow: this.allow === undefined
                ? undefined
                : this.allow?.map((v) => (v == undefined ? undefined : TransactionType.getName(v))),
            deny: this.deny === undefined
                ? undefined
                : this.deny?.map((v) => (v == undefined ? undefined : TransactionType.getName(v))),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(KeyPageOperationType))
], UpdateAllowedKeyPageOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).repeatable.enum)
], UpdateAllowedKeyPageOperation.prototype, "allow", void 0);
__decorate([
    (encodeAs.field(3).repeatable.enum)
], UpdateAllowedKeyPageOperation.prototype, "deny", void 0);
export class UpdateKey {
    constructor(args) {
        this.type = TransactionType.UpdateKey;
        this.newKeyHash =
            args.newKeyHash == undefined
                ? undefined
                : args.newKeyHash instanceof Uint8Array
                    ? args.newKeyHash
                    : Buffer.from(args.newKeyHash, "hex");
    }
    copy() {
        return new UpdateKey(this.asObject());
    }
    asObject() {
        return {
            type: "updateKey",
            newKeyHash: this.newKeyHash === undefined
                ? undefined
                : this.newKeyHash && Buffer.from(this.newKeyHash).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], UpdateKey.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).bytes)
], UpdateKey.prototype, "newKeyHash", void 0);
export class UpdateKeyOperation {
    constructor(args) {
        this.type = KeyPageOperationType.Update;
        this.oldEntry =
            args.oldEntry == undefined
                ? undefined
                : args.oldEntry instanceof KeySpecParams
                    ? args.oldEntry
                    : new KeySpecParams(args.oldEntry);
        this.newEntry =
            args.newEntry == undefined
                ? undefined
                : args.newEntry instanceof KeySpecParams
                    ? args.newEntry
                    : new KeySpecParams(args.newEntry);
    }
    copy() {
        return new UpdateKeyOperation(this.asObject());
    }
    asObject() {
        return {
            type: "update",
            oldEntry: this.oldEntry === undefined ? undefined : this.oldEntry.asObject(),
            newEntry: this.newEntry === undefined ? undefined : this.newEntry.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(KeyPageOperationType))
], UpdateKeyOperation.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).reference)
], UpdateKeyOperation.prototype, "oldEntry", void 0);
__decorate([
    (encodeAs.field(3).reference)
], UpdateKeyOperation.prototype, "newEntry", void 0);
export class UpdateKeyPage {
    constructor(args) {
        this.type = TransactionType.UpdateKeyPage;
        this.operation =
            args.operation == undefined
                ? undefined
                : args.operation.map((v) => (v == undefined ? undefined : KeyPageOperation.fromObject(v)));
    }
    copy() {
        return new UpdateKeyPage(this.asObject());
    }
    asObject() {
        return {
            type: "updateKeyPage",
            operation: this.operation === undefined
                ? undefined
                : this.operation?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], UpdateKeyPage.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).repeatable.union)
], UpdateKeyPage.prototype, "operation", void 0);
export class ValidatorInfo {
    constructor(args) {
        this.publicKey =
            args.publicKey == undefined
                ? undefined
                : args.publicKey instanceof Uint8Array
                    ? args.publicKey
                    : Buffer.from(args.publicKey, "hex");
        this.publicKeyHash =
            args.publicKeyHash == undefined
                ? undefined
                : args.publicKeyHash instanceof Uint8Array
                    ? args.publicKeyHash
                    : Buffer.from(args.publicKeyHash, "hex");
        this.operator = args.operator == undefined ? undefined : URL.parse(args.operator);
        this.partitions =
            args.partitions == undefined
                ? undefined
                : args.partitions.map((v) => v == undefined
                    ? undefined
                    : v instanceof ValidatorPartitionInfo
                        ? v
                        : new ValidatorPartitionInfo(v));
    }
    copy() {
        return new ValidatorInfo(this.asObject());
    }
    asObject() {
        return {
            publicKey: this.publicKey === undefined
                ? undefined
                : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
            publicKeyHash: this.publicKeyHash === undefined
                ? undefined
                : this.publicKeyHash && Buffer.from(this.publicKeyHash).toString("hex"),
            operator: this.operator === undefined ? undefined : this.operator.toString(),
            partitions: this.partitions === undefined
                ? undefined
                : this.partitions?.map((v) => (v == undefined ? undefined : v.asObject())),
        };
    }
}
__decorate([
    (encodeAs.field(1).bytes)
], ValidatorInfo.prototype, "publicKey", void 0);
__decorate([
    (encodeAs.field(2).hash)
], ValidatorInfo.prototype, "publicKeyHash", void 0);
__decorate([
    (encodeAs.field(3).url)
], ValidatorInfo.prototype, "operator", void 0);
__decorate([
    (encodeAs.field(4).repeatable.reference)
], ValidatorInfo.prototype, "partitions", void 0);
export class ValidatorPartitionInfo {
    constructor(args) {
        this.id = args.id == undefined ? undefined : args.id;
        this.active = args.active == undefined ? undefined : args.active;
    }
    copy() {
        return new ValidatorPartitionInfo(this.asObject());
    }
    asObject() {
        return {
            id: this.id === undefined ? undefined : this.id,
            active: this.active === undefined ? undefined : this.active,
        };
    }
}
__decorate([
    (encodeAs.field(1).string)
], ValidatorPartitionInfo.prototype, "id", void 0);
__decorate([
    (encodeAs.field(2).keepEmpty.bool)
], ValidatorPartitionInfo.prototype, "active", void 0);
export class WriteData {
    constructor(args) {
        this.type = TransactionType.WriteData;
        this.entry = args.entry == undefined ? undefined : DataEntry.fromObject(args.entry);
        this.scratch = args.scratch == undefined ? undefined : args.scratch;
        this.writeToState = args.writeToState == undefined ? undefined : args.writeToState;
    }
    copy() {
        return new WriteData(this.asObject());
    }
    asObject() {
        return {
            type: "writeData",
            entry: this.entry === undefined ? undefined : this.entry.asObject(),
            scratch: this.scratch === undefined ? undefined : this.scratch,
            writeToState: this.writeToState === undefined ? undefined : this.writeToState,
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], WriteData.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).union)
], WriteData.prototype, "entry", void 0);
__decorate([
    (encodeAs.field(3).bool)
], WriteData.prototype, "scratch", void 0);
__decorate([
    (encodeAs.field(4).bool)
], WriteData.prototype, "writeToState", void 0);
export class WriteDataResult {
    constructor(args) {
        this.type = TransactionType.WriteData;
        this.entryHash =
            args.entryHash == undefined
                ? undefined
                : args.entryHash instanceof Uint8Array
                    ? args.entryHash
                    : Buffer.from(args.entryHash, "hex");
        this.accountUrl = args.accountUrl == undefined ? undefined : URL.parse(args.accountUrl);
        this.accountID =
            args.accountID == undefined
                ? undefined
                : args.accountID instanceof Uint8Array
                    ? args.accountID
                    : Buffer.from(args.accountID, "hex");
    }
    copy() {
        return new WriteDataResult(this.asObject());
    }
    asObject() {
        return {
            type: "writeData",
            entryHash: this.entryHash === undefined
                ? undefined
                : this.entryHash && Buffer.from(this.entryHash).toString("hex"),
            accountUrl: this.accountUrl === undefined ? undefined : this.accountUrl.toString(),
            accountID: this.accountID === undefined
                ? undefined
                : this.accountID && Buffer.from(this.accountID).toString("hex"),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], WriteDataResult.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).hash)
], WriteDataResult.prototype, "entryHash", void 0);
__decorate([
    (encodeAs.field(3).url)
], WriteDataResult.prototype, "accountUrl", void 0);
__decorate([
    (encodeAs.field(4).bytes)
], WriteDataResult.prototype, "accountID", void 0);
export class WriteDataTo {
    constructor(args) {
        this.type = TransactionType.WriteDataTo;
        this.recipient = args.recipient == undefined ? undefined : URL.parse(args.recipient);
        this.entry = args.entry == undefined ? undefined : DataEntry.fromObject(args.entry);
    }
    copy() {
        return new WriteDataTo(this.asObject());
    }
    asObject() {
        return {
            type: "writeDataTo",
            recipient: this.recipient === undefined ? undefined : this.recipient.toString(),
            entry: this.entry === undefined ? undefined : this.entry.asObject(),
        };
    }
}
__decorate([
    (encodeAs.field(1).keepEmpty.enum.of(TransactionType))
], WriteDataTo.prototype, "type", void 0);
__decorate([
    (encodeAs.field(2).url)
], WriteDataTo.prototype, "recipient", void 0);
__decorate([
    (encodeAs.field(3).union)
], WriteDataTo.prototype, "entry", void 0);
//# sourceMappingURL=types_gen.js.map